<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlowScript</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/icons-webfont@latest/tabler-icons.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-dark: #09090b;
      --bg-editor: #111113;
      --bg-canvas: #09090b;
      --bg-surface: #18181b;
      --bg-sidebar: #0f0f11;
      --border: #27272a;
      --border-hover: #3f3f46;
      --text: #fafafa;
      --text-dim: #71717a;
      --text-muted: #52525b;
      --accent: #22c55e;
      --accent-dim: #14532d;
      --accent-hover: #16a34a;
      --node-fill: #18181b;
      --node-stroke: #3f3f46;
      --node-text: #fafafa;
      --edge-stroke: #52525b;
      --group-fill: rgba(39, 39, 42, 0.5);
      --group-stroke: #3f3f46;
    }

    [data-theme="light"] {
      --bg-dark: #fafafa;
      --bg-editor: #ffffff;
      --bg-canvas: #f4f4f5;
      --bg-surface: #ffffff;
      --bg-sidebar: #f4f4f5;
      --border: #e4e4e7;
      --border-hover: #d4d4d8;
      --text: #09090b;
      --text-dim: #71717a;
      --text-muted: #a1a1aa;
      --accent: #16a34a;
      --accent-dim: #dcfce7;
      --accent-hover: #15803d;
      --node-fill: #ffffff;
      --node-stroke: #d4d4d8;
      --node-text: #09090b;
      --edge-stroke: #a1a1aa;
      --group-fill: rgba(244, 244, 245, 0.8);
      --group-stroke: #d4d4d8;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-dark);
      gap: 12px;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      font-size: 15px;
      font-weight: 600;
      letter-spacing: -0.3px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo-icon {
      width: 26px;
      height: 26px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .logo-icon svg {
      width: 14px;
      height: 14px;
      stroke: white;
    }

    .project-name {
      padding: 4px 10px;
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 12px;
      color: var(--text-dim);
    }

    .project-name strong {
      color: var(--text);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn {
      padding: 6px 12px;
      border-radius: 5px;
      border: 1px solid var(--border);
      background: var(--bg-surface);
      color: var(--text);
      font-family: inherit;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .btn:hover {
      border-color: var(--border-hover);
      background: var(--border);
    }

    .btn-primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .btn-primary:hover {
      background: var(--accent-hover);
    }

    .btn-icon {
      padding: 6px;
      min-width: 28px;
      justify-content: center;
    }

    .btn svg {
      width: 14px;
      height: 14px;
    }

    .btn-ghost {
      border-color: transparent;
      background: transparent;
    }

    .btn-ghost:hover {
      background: var(--border);
      border-color: transparent;
    }

    /* Main Layout */
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar - File Tree */
    .sidebar {
      width: 220px;
      min-width: 180px;
      background: var(--bg-sidebar);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
    }

    .sidebar-header {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-dim);
    }

    .sidebar-actions {
      display: flex;
      gap: 2px;
    }

    .sidebar-btn {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      background: transparent;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 4px;
    }

    .sidebar-btn:hover {
      background: var(--border);
      color: var(--text);
    }

    .sidebar-btn svg {
      width: 14px;
      height: 14px;
    }

    .sidebar-btn.active {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .file-tree {
      flex: 1;
      overflow-y: auto;
      padding: 8px 0;
    }

    .file-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-dim);
      transition: all 0.1s;
      position: relative;
    }

    .file-item:hover {
      background: var(--border);
      color: var(--text);
    }

    .file-item.active {
      background: var(--accent-dim);
      color: var(--accent);
    }

    .file-item.modified::after {
      content: '●';
      font-size: 8px;
      color: var(--accent);
      margin-left: 4px;
    }

    .file-time {
      font-size: 10px;
      color: var(--text-muted);
      margin-left: auto;
      flex-shrink: 0;
    }

    .file-item.modified .file-time {
      display: none;
    }

    .file-item svg.file-icon {
      width: 14px;
      height: 14px;
      flex-shrink: 0;
    }

    .file-delete-btn {
      width: 18px;
      height: 18px;
      padding: 2px;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-muted);
      opacity: 0;
      transition: opacity 0.15s, color 0.15s;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
      margin-left: auto;
    }

    .file-delete-btn:hover {
      color: #ef4444;
      background: rgba(239, 68, 68, 0.1);
    }

    .file-item:hover .file-delete-btn {
      opacity: 1;
    }

    .file-delete-btn svg {
      width: 12px;
      height: 12px;
    }

    .file-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .empty-state {
      padding: 20px;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
    }

    .empty-state p {
      margin-bottom: 12px;
    }

    /* Version History Styles */
    .version-item {
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-bottom: 8px;
      background: var(--bg-dark);
    }

    .version-item:hover {
      border-color: var(--text-muted);
    }

    .version-item.current {
      border-color: var(--accent);
      background: rgba(34, 197, 94, 0.1);
    }

    .version-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 6px;
    }

    .version-comment {
      font-weight: 500;
      color: var(--text);
      font-size: 13px;
    }

    .version-time {
      font-size: 11px;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .version-meta {
      font-size: 11px;
      color: var(--text-dim);
      margin-bottom: 8px;
    }

    .version-actions {
      display: flex;
      gap: 8px;
    }

    .version-actions button {
      padding: 4px 10px;
      font-size: 11px;
    }

    .version-current-badge {
      display: inline-block;
      padding: 2px 6px;
      background: var(--accent);
      color: white;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 500;
      margin-left: 8px;
    }

    .diff-add {
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
    }

    .diff-remove {
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
    }

    .diff-line {
      display: block;
      padding: 1px 4px;
      margin: 0 -4px;
    }

    /* Editor Panel */
    .editor-panel {
      width: 380px;
      min-width: 280px;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border);
      background: var(--bg-editor);
    }

    .panel-header {
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .panel-title {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .panel-title svg {
      width: 14px;
      height: 14px;
      color: var(--text-dim);
    }

    .panel-actions {
      display: flex;
      gap: 4px;
    }

    .editor-wrapper {
      flex: 1;
      overflow: hidden;
    }

    #editor {
      width: 100%;
      height: 100%;
      padding: 12px;
      background: transparent;
      border: none;
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      line-height: 1.6;
      resize: none;
      outline: none;
      tab-size: 2;
    }

    .editor-footer {
      padding: 6px 12px;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-dim);
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
    }

    .status-dot.error {
      background: #ef4444;
    }

    .status-dot.modified {
      background: #eab308;
    }

    /* Canvas Panel */
    .canvas-panel {
      flex: 1;
      background: var(--bg-canvas);
      position: relative;
      overflow: hidden;
    }

    .canvas-container {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    .canvas-container:active {
      cursor: grabbing;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .canvas-controls {
      position: absolute;
      bottom: 12px;
      right: 12px;
      display: flex;
      gap: 6px;
    }

    .control-group {
      display: flex;
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px;
    }

    .canvas-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      border-radius: 4px;
    }

    .canvas-btn:hover {
      background: var(--border);
    }

    .canvas-btn svg {
      width: 14px;
      height: 14px;
    }

    .zoom-display {
      padding: 0 8px;
      font-size: 11px;
      color: var(--text-dim);
      display: flex;
      align-items: center;
    }

    .grid-pattern {
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0.4;
    }

    /* Resize Handles */
    .resize-handle {
      width: 3px;
      background: transparent;
      cursor: col-resize;
    }

    .resize-handle:hover {
      background: var(--accent);
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      max-width: 500px;
      width: 90%;
      padding: 20px;
    }

    .modal h2 {
      font-size: 16px;
      margin-bottom: 12px;
    }

    .modal p {
      font-size: 13px;
      color: var(--text-dim);
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    /* Palette Popover */
    .palette-popover {
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 6px;
      background: var(--bg-surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      min-width: 220px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      z-index: 50;
      display: none;
    }
    .palette-popover.active { display: block; }
    .palette-popover-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-dim);
      margin-bottom: 6px;
      font-weight: 600;
    }
    .palette-popover-row {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }
    .palette-popover-row:last-child { margin-bottom: 0; }
    .palette-pill {
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.15s;
    }
    .palette-pill:hover { border-color: var(--text-dim); }
    .palette-pill.active {
      background: var(--text);
      color: var(--bg-dark);
      border-color: var(--text);
    }
    .palette-swatches {
      display: flex;
      gap: 3px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }
    .palette-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      flex-shrink: 0;
    }

    /* Toast */
    .toast-container {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 200;
    }

    .toast {
      background: var(--bg-surface);
      border: 1px solid var(--border);
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 13px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      animation: slideUp 0.2s ease;
    }

    @keyframes slideUp {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* No Project State */
    .no-project {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 16px;
      color: var(--text-dim);
    }

    .no-project-icon {
      width: 64px;
      height: 64px;
      background: var(--bg-surface);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .no-project-icon svg {
      width: 32px;
      height: 32px;
      stroke: var(--text-muted);
    }

    .no-project h2 {
      font-size: 18px;
      color: var(--text);
    }

    .no-project p {
      font-size: 13px;
      max-width: 300px;
      text-align: center;
      line-height: 1.5;
    }

    .no-project-actions {
      display: flex;
      gap: 10px;
      margin-top: 8px;
    }

    /* Keyboard shortcut hints */
    kbd {
      background: var(--bg-dark);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 2px 5px;
      font-size: 11px;
      font-family: inherit;
    }

    /* Mobile */
    @media (max-width: 768px) {
      .sidebar {
        display: none;
      }
      .editor-panel {
        width: 100% !important;
      }
      .canvas-panel.hidden {
        display: none;
      }
      .editor-panel.hidden {
        display: none;
      }
    }

    /* Help content in modal */
    .help-section {
      margin-bottom: 16px;
    }
    
    .help-section h3 {
      font-size: 12px;
      color: var(--accent);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .help-section pre {
      background: var(--bg-dark);
      padding: 10px;
      border-radius: 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      line-height: 1.5;
      overflow-x: auto;
    }
  </style>
  <script defer data-domain="fs.gnkz.net" src="https://plausible.gnkz.net/js/script.file-downloads.outbound-links.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div class="header-left">
        <div class="logo">
          <div class="logo-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
              <path d="M4 4h6v6H4zM14 4h6v6h-6zM9 14h6v6H9z"/>
              <path d="M7 10v4M17 10v1c0 1.5-1 3-3 3h-2"/>
            </svg>
          </div>
          FlowScript
          <span id="appVersion" style="font-size: 10px; color: var(--text-muted); font-weight: 400; margin-left: 6px;">v0.14.4</span>
        </div>
        <div class="project-name" id="projectName" style="display:none;">
          <span id="projectLabel">No project open</span>
        </div>
      </div>
      <div class="header-actions">
        <button class="btn" id="openFolderHeaderBtn" title="Open project folder (Ctrl+O)" style="display:none;">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2v11z"/>
          </svg>
          Open Folder
        </button>
        <button class="btn btn-ghost" id="helpBtn" title="Help">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"/>
            <path d="M9.09 9a3 3 0 015.83 1c0 2-3 3-3 3M12 17h.01"/>
          </svg>
        </button>
        <div style="position:relative;">
          <button class="btn btn-ghost" id="paletteBtn" title="Color palette">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="13.5" cy="6.5" r="2"/>
              <circle cx="17.5" cy="10.5" r="2"/>
              <circle cx="8.5" cy="7.5" r="2"/>
              <circle cx="6.5" cy="12" r="2"/>
              <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.9 0 1.5-.7 1.5-1.5 0-.4-.1-.7-.4-1-.3-.3-.4-.7-.4-1.1 0-.8.7-1.5 1.5-1.5H16c3.3 0 6-2.7 6-6 0-5.5-4.5-9.9-10-9.9z"/>
            </svg>
          </button>
          <div class="palette-popover" id="palettePopover">
            <div class="palette-popover-label">Set</div>
            <div class="palette-popover-row" id="paletteSetRow">
              <button class="palette-pill active" data-set="tailwind">Tailwind</button>
              <button class="palette-pill" data-set="material">Material</button>
            </div>
            <div class="palette-popover-label">Shade</div>
            <div class="palette-popover-row" id="paletteShadeRow">
              <button class="palette-pill" data-shade="300">300</button>
              <button class="palette-pill active" data-shade="400">400</button>
              <button class="palette-pill" data-shade="500">500</button>
              <button class="palette-pill" data-shade="600">600</button>
              <button class="palette-pill" data-shade="700">700</button>
            </div>
            <div class="palette-swatches" id="paletteSwatches"></div>
          </div>
        </div>
        <button class="btn btn-ghost" id="themeBtn" title="Toggle theme">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"/>
            <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
          </svg>
        </button>
        <div class="btn-group">
          <button class="btn" id="exportSvgBtn" title="Export diagram as SVG">SVG</button>
          <button class="btn" id="exportPngBtn" title="Export diagram as PNG">PNG</button>
        </div>
      </div>
    </header>

    <div class="main" id="mainContent">
      <!-- No Project State -->
      <div class="no-project" id="noProjectState" style="display:none;">
        <div class="no-project-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2v11z"/>
          </svg>
        </div>
        <h2>Open a Project Folder</h2>
        <p>Select a folder to store your flowcharts. FlowScript will read and save .flow files directly to your local file system.</p>
        <div class="no-project-actions">
          <button class="btn btn-primary" id="openFolderBtn">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2v11z"/>
            </svg>
            Open Folder
          </button>
        </div>
        <p style="font-size: 11px; margin-top: 16px;">
          Or drag & drop a folder here
        </p>
      </div>

      <!-- Project View (hidden by default) -->
      <div class="sidebar" id="sidebar" style="display: none;">
        <div class="sidebar-header">
          <span class="sidebar-title">Files</span>
          <div class="sidebar-actions">
            <button class="sidebar-btn" id="openFolderSidebarBtn" title="Open folder" style="display:none;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2v11z"/>
              </svg>
            </button>
            <button class="sidebar-btn active" id="sortNameBtn" data-sort="name" title="Sort by name">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 6h12M3 12h9M3 18h6M18 6v12M15 15l3 3 3-3"/>
              </svg>
            </button>
            <button class="sidebar-btn" id="sortRecentBtn" data-sort="recent" title="Sort by recent">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="9"/><path d="M12 6v6l4 2"/>
              </svg>
            </button>
            <div style="width: 1px; height: 16px; background: var(--border); margin: 0 2px;"></div>
            <button class="sidebar-btn" id="newFileBtn" title="New file">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 5v14M5 12h14"/>
              </svg>
            </button>
            <button class="sidebar-btn" id="refreshBtn" title="Refresh">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 4v6h-6M1 20v-6h6"/>
                <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="file-tree" id="fileTree">
          <div class="empty-state">
            <p>No .flow files yet</p>
            <button class="btn" id="createFirstBtn">Create first file</button>
          </div>
        </div>
      </div>

      <div class="resize-handle" id="sidebarResize" style="display: none;"></div>

      <div class="editor-panel" id="editorPanel" style="display: none;">
        <div class="panel-header">
          <div class="panel-title">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z"/>
              <path d="M14 2v6h6M16 13H8M16 17H8M10 9H8"/>
            </svg>
            <span id="currentFileName">untitled.flow</span>
          </div>
        </div>
        <div class="editor-wrapper">
          <textarea id="editor" spellcheck="false" placeholder="// Start typing your flowchart...

Start [shape: oval]
Process
End [shape: oval]

Start > Process
Process > End"></textarea>
        </div>
        <div class="editor-footer">
          <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Ready</span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <button class="btn" id="versionsBtn" title="Version History" style="padding: 4px 8px; font-size: 11px;">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 4px;">
                <circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/>
              </svg>
              History
            </button>
            <span id="saveStatus"></span>
          </div>
        </div>
      </div>

      <div class="resize-handle" id="editorResize" style="display: none;"></div>

      <div class="canvas-panel" id="canvasPanel" style="display: none;">
        <svg class="grid-pattern" id="gridPattern"></svg>
        <div class="canvas-container" id="canvasContainer">
          <svg id="canvas"></svg>
        </div>
        <div class="canvas-controls">
          <div class="control-group">
            <button class="canvas-btn" id="zoomOutBtn" title="Zoom out">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35M8 11h6"/>
              </svg>
            </button>
            <span class="zoom-display" id="zoomDisplay">100%</span>
            <button class="canvas-btn" id="zoomInBtn" title="Zoom in">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35M8 11h6M11 8v6"/>
              </svg>
            </button>
          </div>
          <div class="control-group">
            <button class="canvas-btn" id="fitBtn" title="Fit to view">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M8 3H5a2 2 0 00-2 2v3M21 8V5a2 2 0 00-2-2h-3M3 16v3a2 2 0 002 2h3M16 21h3a2 2 0 002-2v-3"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div class="modal-overlay" id="helpModal">
    <div class="modal" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
      <h2>FlowScript Quick Reference</h2>
      <p style="font-size: 12px; color: var(--text-dim); margin-bottom: 16px;">Eraser.io compatible syntax</p>
      
      <div class="help-section">
        <h3>Nodes with Properties</h3>
        <pre>Start [shape: oval]
Check [shape: diamond]
Input [shape: parallelogram]
Store [shape: cylinder]
Process                    // rectangle (default)
Node [shape: oval, color: green, icon: check]</pre>
      </div>

      <div class="help-section">
        <h3>Shapes</h3>
        <pre>rectangle, oval, diamond, cylinder
parallelogram, document, hexagon
trapezoid, triangle, ellipse, star</pre>
      </div>

      <div class="help-section">
        <h3>Text Modes</h3>
        <pre>Long node name           // wrap (default)
Node [text: fit]         // shrink font to fit
Node [text: clip]        // truncate with ...</pre>
      </div>

      <div class="help-section">
        <h3>Connections</h3>
        <pre>A > B                   // Arrow
A > B: label            // With label
A > B > C               // Chain
A > B, C, D             // Branching
A - B                   // Line (no arrow)
A -- B                  // Dotted line
A --> B                 // Dotted arrow
A <> B                  // Bidirectional</pre>
      </div>

      <div class="help-section">
        <h3>Groups</h3>
        <pre>Backend [color: blue] {
  API [icon: api]
  Database [shape: cylinder]
}

Frontend > Backend: REST API</pre>
      </div>

      <div class="help-section">
        <h3>Icons (Tabler Icons - 5000+)</h3>
        <pre style="font-size: 10px; line-height: 1.4;">// Use ANY icon from tabler-icons.io <a href='https://tabler.io/icons' target='_blank'>Search</a>
// Examples:
user, users, settings, home, bell
code, terminal, git, bug, brand-github
server, database, cloud, api, network
mail, message, phone, send, inbox
file, folder, download, upload, clipboard
check, x, alert, info, plus, minus
lock, key, shield, fingerprint, eye
photo, video, music, camera, microphone
arrow-right, chevron, external, link
clock, calendar, hourglass
chart-bar, graph, trending-up
shopping-cart, credit-card, currency-dollar
world, location, map-pin, compass
docker, brand-aws, cpu, device-mobile
share, star, heart, bookmark, thumb-up
brand-aws,brand-google,brand-apple

Usage: Node [icon: brand-github]</pre>
      </div>

      <div class="help-section">
        <h3>Colors</h3>
        <pre style="font-size: 10px; line-height: 1.4;">// Primary
red, green, blue, yellow, purple
orange, pink, cyan

// Extended
teal, indigo, violet, fuchsia, rose
lime, emerald, sky, amber

// Neutrals
gray, slate, zinc, stone

// Special
brown, black, white

// Light variants
light-red, light-green, light-blue
light-yellow, light-purple, light-pink
light-orange, light-cyan

// Dark variants
dark-red, dark-green, dark-blue
dark-purple, dark-orange

Usage: Node [color: emerald]
Or hex: Node [color: #3b82f6]</pre>
      </div>

      <div class="help-section">
        <h3>Direction</h3>
        <pre>direction down    // default (top-to-bottom)
direction up      // bottom-to-top
direction right
direction left
direction top     // alias for down
direction bottom  // alias for up</pre>
      </div>

      <div class="help-section">
        <h3>Keyboard Shortcuts</h3>
        <pre>Ctrl+S          Save version (with comment)
Ctrl+N          New file</pre>
      </div>

      <div class="help-section">
        <h3>Version History</h3>
        <pre>• Auto-saves every 5 minutes
• Click "History" to view versions
• Compare, preview, and restore
• Ctrl+S to save with description</pre>
      </div>

      <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid var(--border); font-size: 12px; color: var(--text-dim); text-align: center;">
        <div style="margin-bottom: 8px;">
          <a href="https://gnkz.net" target="_blank" rel="noopener noreferrer" style="color: var(--text); text-decoration: none; font-weight: 500;">by Gün</a>
        </div>
        <div>
          <a href="https://github.com/gunkaragoz/flowscript" target="_blank" rel="noopener noreferrer" style="color: var(--text-dim); text-decoration: none; display: inline-flex; align-items: center; gap: 4px;">
            <svg width="14" height="14" viewBox="0 0 16 16" fill="currentColor">
              <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
            </svg>
            Personal Project
          </a>
        </div>
      </div>

      <div class="modal-actions">
        <button class="btn btn-primary" onclick="document.getElementById('helpModal').classList.remove('active')">Got it</button>
      </div>
    </div>
  </div>

  <!-- Delete Confirmation Modal -->
  <div class="modal-overlay" id="deleteModal">
    <div class="modal">
      <h2>Delete File?</h2>
      <p>Are you sure you want to delete <strong id="deleteFileName"></strong>? This cannot be undone.</p>
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('deleteModal').classList.remove('active')">Cancel</button>
        <button class="btn" style="background: #ef4444; border-color: #ef4444; color: white;" id="confirmDeleteBtn">Delete</button>
      </div>
    </div>
  </div>

  <!-- New File Modal -->
  <div class="modal-overlay" id="newFileModal">
    <div class="modal">
      <h2>New File</h2>
      <p>Enter a name for your new flowchart:</p>
      <input type="text" id="newFileInput" placeholder="my-flowchart" style="
        width: 100%;
        padding: 10px;
        margin-bottom: 16px;
        background: var(--bg-dark);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-family: inherit;
        font-size: 14px;
        outline: none;
      ">
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('newFileModal').classList.remove('active')">Cancel</button>
        <button class="btn btn-primary" id="confirmNewFileBtn">Create</button>
      </div>
    </div>
  </div>

  <!-- Save Version Modal -->
  <div class="modal-overlay" id="saveVersionModal">
    <div class="modal">
      <h2>Save Version</h2>
      <p>Add a description for this version:</p>
      <input type="text" id="versionCommentInput" placeholder="e.g., Added login flow" style="
        width: 100%;
        padding: 10px;
        margin-bottom: 16px;
        background: var(--bg-dark);
        border: 1px solid var(--border);
        border-radius: 6px;
        color: var(--text);
        font-family: inherit;
        font-size: 14px;
        outline: none;
      ">
      <div class="modal-actions">
        <button class="btn" onclick="document.getElementById('saveVersionModal').classList.remove('active')">Cancel</button>
        <button class="btn btn-primary" id="confirmSaveVersionBtn">Save Version</button>
      </div>
    </div>
  </div>

  <!-- Version History Modal -->
  <div class="modal-overlay" id="versionHistoryModal">
    <div class="modal" style="max-width: 700px; max-height: 80vh; display: flex; flex-direction: column;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
        <h2 style="margin: 0;">Version History</h2>
        <button class="btn btn-primary" id="saveNewVersionBtn" style="padding: 6px 12px; font-size: 12px;">
          + Save Current
        </button>
      </div>
      <div id="versionList" style="flex: 1; overflow-y: auto; margin: 0 -20px; padding: 0 20px;"></div>
      <div class="modal-actions" style="margin-top: 16px;">
        <button class="btn" onclick="document.getElementById('versionHistoryModal').classList.remove('active')">Close</button>
      </div>
    </div>
  </div>

  <!-- Version Compare Modal -->
  <div class="modal-overlay" id="versionCompareModal">
    <div class="modal" style="max-width: 900px; max-height: 85vh; display: flex; flex-direction: column;">
      <h2 style="margin-bottom: 16px;">Compare Versions</h2>
      <div style="display: flex; gap: 16px; margin-bottom: 12px;">
        <div style="flex: 1;">
          <label style="font-size: 12px; color: var(--text-dim);">Version: <span id="compareLeftLabel"></span></label>
        </div>
        <div style="flex: 1;">
          <label style="font-size: 12px; color: var(--text-dim);">Version: <span id="compareRightLabel"></span></label>
        </div>
      </div>
      <div id="compareContainer" style="display: flex; gap: 16px; flex: 1; overflow: hidden;">
        <div style="flex: 1; display: flex; flex-direction: column; min-width: 0;">
          <pre id="compareLeft" style="
            flex: 1;
            margin: 0;
            padding: 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 11px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
          "></pre>
        </div>
        <div style="flex: 1; display: flex; flex-direction: column; min-width: 0;">
          <pre id="compareRight" style="
            flex: 1;
            margin: 0;
            padding: 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 11px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
          "></pre>
        </div>
      </div>
      <div class="modal-actions" style="margin-top: 16px;">
        <button class="btn" id="restoreVersionBtn" style="background: var(--accent); border-color: var(--accent);">Restore Left Version</button>
        <button class="btn" onclick="document.getElementById('versionCompareModal').classList.remove('active')">Close</button>
      </div>
    </div>
  </div>

  <div class="toast-container" id="toastContainer"></div>

  <script src="https://cdn.jsdelivr.net/npm/elkjs@0.9.3/lib/elk.bundled.js"></script>
  <script>
    // ============================================
    // FlowScript - Local File System Version
    // ============================================

    // Check for File System Access API support
    const hasFileSystemAccess = 'showDirectoryPicker' in window;

    // Load and display version
    fetch('version.json')
      .then(res => res.json())
      .then(data => {
        const versionEl = document.getElementById('appVersion');
        if (versionEl) {
          const currentVersion = data.version;
          versionEl.textContent = `v${currentVersion}`;

          // Check for updates
          checkForUpdates(currentVersion, versionEl);
        }
      })
      .catch(err => {
        console.warn('Failed to load version:', err);
      });

    // Check for new version on GitHub
    function checkForUpdates(currentVersion, versionEl) {
      fetch('https://api.github.com/repos/gunkaragoz/flowscript/releases/latest')
        .then(res => res.json())
        .then(release => {
          const latestVersion = release.tag_name.replace(/^v/, ''); // Remove 'v' prefix

          if (isNewerVersion(latestVersion, currentVersion)) {
            // Add update indicator
            const updateIndicator = document.createElement('a');
            updateIndicator.href = release.html_url;
            updateIndicator.target = '_blank';
            updateIndicator.rel = 'noopener noreferrer';
            updateIndicator.innerHTML = ' *';
            updateIndicator.title = 'There is a new version available';
            updateIndicator.style.cssText = 'color: #22c55e; text-decoration: none; cursor: pointer; font-weight: 600;';
            versionEl.appendChild(updateIndicator);
          }
        })
        .catch(err => {
          console.warn('Failed to check for updates:', err);
        });
    }

    // Compare semantic versions (e.g., "0.4.1" vs "0.5.0")
    function isNewerVersion(latest, current) {
      const latestParts = latest.split('.').map(Number);
      const currentParts = current.split('.').map(Number);

      for (let i = 0; i < 3; i++) {
        const latestPart = latestParts[i] || 0;
        const currentPart = currentParts[i] || 0;

        if (latestPart > currentPart) return true;
        if (latestPart < currentPart) return false;
      }

      return false; // Versions are equal
    }

    // State
    let state = {
      directoryHandle: null,
      files: new Map(), // filename -> { handle, content, modified, lastUpdated }
      currentFile: null,
      zoom: 1,
      pan: { x: 0, y: 0 },
      theme: 'dark',
      sortBy: 'name', // 'name' or 'recent'
      palette: {
        light: { set: 'tailwind', shade: 400 },
        dark: { set: 'tailwind', shade: 600 }
      }
    };

    // DOM Elements
    const editor = document.getElementById('editor');
    const canvas = document.getElementById('canvas');
    const canvasContainer = document.getElementById('canvasContainer');
    const fileTree = document.getElementById('fileTree');
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    const zoomDisplay = document.getElementById('zoomDisplay');
    const saveStatus = document.getElementById('saveStatus');

    const elk = new ELK();

    // Icons for nodes (Tabler Icons - https://github.com/tabler/tabler-icons)
    const icons = {
      // Common
      user: 'M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2',
      users: 'M9 7m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2M16 3.13a4 4 0 0 1 0 7.75M21 21v-2a4 4 0 0 0 -3 -3.85',
      settings: 'M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065zM9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0',
      home: 'M5 12l-2 0l9 -9l9 9l-2 0l0 7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2l0 -7z',
      bell: 'M10 5a2 2 0 1 1 4 0a7 7 0 0 1 4 6v3a4 4 0 0 0 2 3h-16a4 4 0 0 0 2 -3v-3a7 7 0 0 1 4 -6M9 17v1a3 3 0 0 0 6 0v-1',

      // Development
      code: 'M7 8l-4 4l4 4M17 8l4 4l-4 4M14 4l-4 16',
      terminal: 'M5 7l5 5l-5 5M12 19l7 0',
      git: 'M16 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0M12 8m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0M12 16m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0M12 15v-6M15 11l-2 -2M11 7l-1.9 -1.9M13.446 2.6l7.955 7.954a2.045 2.045 0 0 1 0 2.892l-7.955 7.955a2.045 2.045 0 0 1 -2.892 0l-7.955 -7.955a2.045 2.045 0 0 1 0 -2.892l7.955 -7.955a2.045 2.045 0 0 1 2.892 0z',
      bug: 'M9 9v-1a3 3 0 0 1 6 0v1M8 9h8a6 6 0 0 1 1 3v3a5 5 0 0 1 -10 0v-3a6 6 0 0 1 1 -3M3 13l4 0M17 13l4 0M12 20l0 -6M4 19l3.35 -2M20 19l-3.35 -2M4 7l3.75 2.4M20 7l-3.75 2.4',

      // Infrastructure
      server: 'M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v2a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3zM3 12m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v2a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3zM7 8l0 .01M7 16l0 .01',
      database: 'M12 6m-8 0a8 3 0 1 0 16 0a8 3 0 1 0 -16 0M4 6v6a8 3 0 0 0 16 0v-6M4 12v6a8 3 0 0 0 16 0v-6',
      cloud: 'M6.657 18c-2.572 0 -4.657 -2.007 -4.657 -4.483c0 -2.475 2.085 -4.482 4.657 -4.482c.393 -1.762 1.794 -3.2 3.675 -3.773c1.88 -.572 3.956 -.193 5.444 1c1.488 1.19 2.162 3.007 1.77 4.769h.99c1.913 0 3.464 1.56 3.464 3.486c0 1.927 -1.551 3.487 -3.465 3.487h-11.878',
      api: 'M4 13h5M12 16v-8h3a2 2 0 0 1 2 2v1a2 2 0 0 1 -2 2h-3M20 8v8M9 16v-5.5a2.5 2.5 0 0 0 -5 0v5.5',
      network: 'M6 9a6 6 0 1 0 12 0a6 6 0 0 0 -12 0M12 3c1.333 .333 2 2.333 2 6s-.667 5.667 -2 6M12 3c-1.333 .333 -2 2.333 -2 6s.667 5.667 2 6M6 9h12M3 20h7M14 20h7M10 20a2 2 0 1 0 4 0a2 2 0 0 0 -4 0M12 15v3',

      // Communication
      mail: 'M3 7a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-10zM3 7l9 6l9 -6',
      message: 'M8 9h8M8 13h6M18 4a3 3 0 0 1 3 3v8a3 3 0 0 1 -3 3h-5l-5 3v-3h-2a3 3 0 0 1 -3 -3v-8a3 3 0 0 1 3 -3h12z',
      phone: 'M5 4h4l2 5l-2.5 1.5a11 11 0 0 0 5 5l1.5 -2.5l5 2v4a2 2 0 0 1 -2 2a16 16 0 0 1 -15 -15a2 2 0 0 1 2 -2',
      send: 'M10 14l11 -11M21 3l-6.5 18a.55 .55 0 0 1 -1 0l-3.5 -7l-7 -3.5a.55 .55 0 0 1 0 -1l18 -6.5',

      // Files & Documents
      file: 'M14 3v4a1 1 0 0 0 1 1h4M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z',
      folder: 'M5 4h4l3 3h7a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2',
      download: 'M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2M7 11l5 5l5 -5M12 4l0 12',
      upload: 'M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2M7 9l5 -5l5 5M12 4l0 12',

      // Status & Actions
      check: 'M5 12l5 5l10 -10',
      x: 'M18 6l-12 12M6 6l12 12',
      alert: 'M12 9v4M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0zM12 16h.01',
      info: 'M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0M12 9h.01M11 12h1v4h1',
      plus: 'M12 5l0 14M5 12l14 0',
      minus: 'M5 12l14 0',

      // Security
      lock: 'M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6zM11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0M8 11v-4a4 4 0 1 1 8 0v4',
      key: 'M16.555 3.843l3.602 3.602a2.877 2.877 0 0 1 0 4.069l-2.643 2.643a2.877 2.877 0 0 1 -4.069 0l-.301 -.301l-6.558 6.558a2 2 0 0 1 -1.239 .578l-.175 .008h-1.172a1 1 0 0 1 -.993 -.883l-.007 -.117v-1.172a2 2 0 0 1 .467 -1.284l.119 -.13l.414 -.414h2v-2h2v-2l2.144 -2.144l-.301 -.301a2.877 2.877 0 0 1 0 -4.069l2.643 -2.643a2.877 2.877 0 0 1 4.069 0zM15 9h.01',
      shield: 'M12 3a12 12 0 0 0 8.5 3a12 12 0 0 1 -8.5 15a12 12 0 0 1 -8.5 -15a12 12 0 0 0 8.5 -3',

      // Media & Content
      photo: 'M15 8h.01M3 6a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3v-12zM3 16l5 -5c.928 -.893 2.072 -.893 3 0l5 5M14 14l1 -1c.928 -.893 2.072 -.893 3 0l3 3',
      video: 'M15 10l4.553 -2.276a1 1 0 0 1 1.447 .894v6.764a1 1 0 0 1 -1.447 .894l-4.553 -2.276v-4zM3 6m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z',
      music: 'M3 17a3 3 0 1 0 6 0a3 3 0 0 0 -6 0M13 17a3 3 0 1 0 6 0a3 3 0 0 0 -6 0M9 17v-13h10v13M9 8h10',

      // Navigation
      arrow: 'M5 12l14 0M5 12l6 6M5 12l6 -6',
      chevron: 'M9 6l6 6l-6 6',
      external: 'M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6M11 13l9 -9M15 4h5v5',
      link: 'M9 15l6 -6M11 6l.463 -.536a5 5 0 0 1 7.071 7.072l-.534 .464M13 18l-.397 .534a5.068 5.068 0 0 1 -7.127 0a4.972 4.972 0 0 1 0 -7.071l.524 -.463',

      // Time & Calendar
      clock: 'M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0M12 7v5l3 3',
      calendar: 'M4 7a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12zM16 3v4M8 3v4M4 11h16M11 15h1M12 15v3',

      // Charts & Analytics
      chart: 'M3 13a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1zM15 9a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v10a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1zM9 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v14a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z',
      graph: 'M4 19l16 0M4 15l4 -6l4 2l4 -5l4 4',

      // Business & Commerce
      shopping: 'M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0M17 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0M17 17h-11v-14h-2M6 5l14 1l-1 7h-13',
      credit: 'M3 5m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v8a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3zM3 10l18 0M7 15l.01 0M11 15l2 0',
      currency: 'M16.7 8a3 3 0 0 0 -2.7 -2h-4a3 3 0 0 0 0 6h4a3 3 0 0 1 0 6h-4a3 3 0 0 1 -2.7 -2M12 3v3m0 12v3',

      // World & Location
      world: 'M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0M3.6 9h16.8M3.6 15h16.8M11.5 3a17 17 0 0 0 0 18M12.5 3a17 17 0 0 1 0 18',
      location: 'M9 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0M17.657 16.657l-4.243 4.243a2 2 0 0 1 -2.827 0l-4.244 -4.243a8 8 0 1 1 11.314 0z',
      map: 'M3 7l6 -3l6 3l6 -3v13l-6 3l-6 -3l-6 3v-13M9 4v13M15 7v13',

      // Tech & Brands
      docker: 'M22 12.54c-1.804 -.345 -2.701 -1.08 -3.523 -2.94c-.487 .696 -1.102 1.568 -.92 2.4c.028 .238 -.32 1 -.557 1h-14c0 5.208 3.164 7 6.196 7c4.124 .022 7.828 -1.376 9.854 -5c1.146 -.101 2.296 -1.505 2.95 -2.46M5 10h3v3h-3zM8 10h3v3h-3zM11 10h3v3h-3zM8 7h3v3h-3zM11 7h3v3h-3zM11 4h3v3h-3zM4.571 18c1.5 0 2.047 -.074 2.958 -.78',
      brand: 'M3 7a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v2a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3zM8 7m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0M3 16a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v2a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3zM8 16m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0',
      cpu: 'M5 5m0 1a1 1 0 0 1 1 -1h12a1 1 0 0 1 1 1v12a1 1 0 0 1 -1 1h-12a1 1 0 0 1 -1 -1zM9 9h6v6h-6zM3 10h2M3 14h2M19 10h2M19 14h2M10 3v2M14 3v2M10 19v2M14 19v2',

      // Social
      share: 'M6 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0M18 6m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0M8.7 10.7l6.6 -3.4M8.7 13.3l6.6 3.4',
      star: 'M12 17.75l-6.172 3.245l1.179 -6.873l-5 -4.867l6.9 -1l3.086 -6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z',
      heart: 'M19.5 12.572l-7.5 7.428l-7.5 -7.428a5 5 0 1 1 7.5 -6.566a5 5 0 1 1 7.5 6.572',
    };

    // Extended Tabler Icons library - loaded from CDN
    // Provides access to 5000+ icons beyond the hardcoded set above
    let tablerIconsDB = null; // Will be populated from CDN
    const tablerIconsLoading = fetch('https://cdn.jsdelivr.net/npm/@tabler/icons@latest/tabler-nodes-outline.json')
      .then(r => r.json())
      .then(data => {
        tablerIconsDB = data;
        console.log(`Loaded ${Object.keys(data).length} Tabler icons from CDN`);
      })
      .catch(e => console.warn('Could not load extended Tabler icons:', e));

    // Unified icon lookup: checks hardcoded first (instant), then Tabler DB
    // Returns an array of SVG path strings for the icon, or null if not found
    function getIconPaths(iconName) {
      if (!iconName) return null;
      // 1. Check hardcoded icons (single path string)
      if (icons[iconName]) return [icons[iconName]];
      // 2. Check Tabler DB (array of [tag, {d: ...}] entries)
      if (tablerIconsDB && tablerIconsDB[iconName]) {
        const paths = tablerIconsDB[iconName]
          .filter(entry => entry[0] === 'path' && entry[1] && entry[1].d)
          .filter(entry => entry[1].d !== 'M0 0h24v24H0z') // skip bounding box
          .map(entry => entry[1].d);
        if (paths.length > 0) return paths;
      }
      return null;
    }

    // Check if an icon name is valid (exists in either source)
    function hasIcon(iconName) {
      return getIconPaths(iconName) !== null;
    }

    // Eraser-compatible shape mapping
    const shapeMap = {
      rectangle: { shape: 'rect', radius: 4 },
      cylinder: { shape: 'cylinder' },
      diamond: { shape: 'diamond' },
      document: { shape: 'document' },
      ellipse: { shape: 'ellipse' },
      hexagon: { shape: 'hexagon' },
      oval: { shape: 'stadium' },
      parallelogram: { shape: 'parallelogram' },
      star: { shape: 'star' },
      trapezoid: { shape: 'trapezoid' },
      triangle: { shape: 'triangle' },
      // Default
      default: { shape: 'rect', radius: 4 }
    };

    // ============================================
    // Color Palette System
    // ============================================
    const paletteSets = {
      tailwind: {
        300: { red:'#fca5a5',green:'#86efac',blue:'#93c5fd',yellow:'#fde047',purple:'#d8b4fe',orange:'#fdba74',pink:'#f9a8d4',cyan:'#67e8f9',teal:'#5eead4',indigo:'#a5b4fc',violet:'#c4b5fd',fuchsia:'#f0abfc',rose:'#fda4af',lime:'#bef264',emerald:'#6ee7b7',sky:'#7dd3fc',amber:'#fcd34d' },
        400: { red:'#f87171',green:'#4ade80',blue:'#60a5fa',yellow:'#facc15',purple:'#c084fc',orange:'#fb923c',pink:'#f472b6',cyan:'#22d3ee',teal:'#2dd4bf',indigo:'#818cf8',violet:'#a78bfa',fuchsia:'#e879f9',rose:'#fb7185',lime:'#a3e635',emerald:'#34d399',sky:'#38bdf8',amber:'#fbbf24' },
        500: { red:'#ef4444',green:'#22c55e',blue:'#3b82f6',yellow:'#eab308',purple:'#a855f7',orange:'#f97316',pink:'#ec4899',cyan:'#06b6d4',teal:'#14b8a6',indigo:'#6366f1',violet:'#8b5cf6',fuchsia:'#d946ef',rose:'#f43f5e',lime:'#84cc16',emerald:'#10b981',sky:'#0ea5e9',amber:'#f59e0b' },
        600: { red:'#dc2626',green:'#16a34a',blue:'#2563eb',yellow:'#ca8a04',purple:'#9333ea',orange:'#ea580c',pink:'#db2777',cyan:'#0891b2',teal:'#0d9488',indigo:'#4f46e5',violet:'#7c3aed',fuchsia:'#c026d3',rose:'#e11d48',lime:'#65a30d',emerald:'#059669',sky:'#0284c7',amber:'#d97706' },
        700: { red:'#b91c1c',green:'#15803d',blue:'#1d4ed8',yellow:'#a16207',purple:'#7e22ce',orange:'#c2410c',pink:'#be185d',cyan:'#0e7490',teal:'#0f766e',indigo:'#4338ca',violet:'#6d28d9',fuchsia:'#a21caf',rose:'#be123c',lime:'#4d7c0f',emerald:'#047857',sky:'#0369a1',amber:'#b45309' }
      },
      material: {
        300: { red:'#e57373',green:'#81c784',blue:'#64b5f6',yellow:'#fff176',purple:'#ba68c8',orange:'#ffb74d',pink:'#f06292',cyan:'#4dd0e1',teal:'#4db6ac',indigo:'#7986cb',violet:'#9575cd',fuchsia:'#ce93d8',rose:'#ef9a9a',lime:'#dce775',emerald:'#81c784',sky:'#4fc3f7',amber:'#ffd54f' },
        400: { red:'#ef5350',green:'#66bb6a',blue:'#42a5f5',yellow:'#ffee58',purple:'#ab47bc',orange:'#ffa726',pink:'#ec407a',cyan:'#26c6da',teal:'#26a69a',indigo:'#5c6bc0',violet:'#7e57c2',fuchsia:'#ce93d8',rose:'#ec407a',lime:'#d4e157',emerald:'#66bb6a',sky:'#29b6f6',amber:'#ffca28' },
        500: { red:'#f44336',green:'#4caf50',blue:'#2196f3',yellow:'#ffeb3b',purple:'#9c27b0',orange:'#ff9800',pink:'#e91e63',cyan:'#00bcd4',teal:'#009688',indigo:'#3f51b5',violet:'#673ab7',fuchsia:'#ab47bc',rose:'#e91e63',lime:'#cddc39',emerald:'#4caf50',sky:'#03a9f4',amber:'#ffc107' },
        600: { red:'#e53935',green:'#43a047',blue:'#1e88e5',yellow:'#fdd835',purple:'#8e24aa',orange:'#fb8c00',pink:'#d81b60',cyan:'#00acc1',teal:'#00897b',indigo:'#3949ab',violet:'#5e35b1',fuchsia:'#8e24aa',rose:'#d81b60',lime:'#c0ca33',emerald:'#43a047',sky:'#039be5',amber:'#ffb300' },
        700: { red:'#d32f2f',green:'#388e3c',blue:'#1976d2',yellow:'#fbc02d',purple:'#7b1fa2',orange:'#f57c00',pink:'#c2185b',cyan:'#0097a7',teal:'#00796b',indigo:'#303f9f',violet:'#512da8',fuchsia:'#7b1fa2',rose:'#c2185b',lime:'#afb42b',emerald:'#388e3c',sky:'#0288d1',amber:'#ffa000' }
      }
    };

    // Light/dark variant shade offsets
    const lightDarkShades = {
      tailwind: { 300: { light: 200, dark: 500 }, 400: { light: 200, dark: 600 }, 500: { light: 300, dark: 700 }, 600: { light: 300, dark: 800 }, 700: { light: 400, dark: 900 } },
      material: { 300: { light: 100, dark: 500 }, 400: { light: 200, dark: 600 }, 500: { light: 300, dark: 700 }, 600: { light: 300, dark: 800 }, 700: { light: 400, dark: 900 } }
    };

    // Light/dark variant overrides (hardcoded since we only store main shades)
    const paletteVariants = {
      tailwind: {
        light: {
          300: { red:'#fecaca',green:'#bbf7d0',blue:'#bfdbfe',yellow:'#fef08a',purple:'#e9d5ff',orange:'#fed7aa',pink:'#fbcfe8',cyan:'#a5f3fc' },
          400: { red:'#fecaca',green:'#bbf7d0',blue:'#bfdbfe',yellow:'#fef08a',purple:'#e9d5ff',orange:'#fed7aa',pink:'#fbcfe8',cyan:'#a5f3fc' },
          500: { red:'#fca5a5',green:'#86efac',blue:'#93c5fd',yellow:'#fde047',purple:'#d8b4fe',orange:'#fdba74',pink:'#f9a8d4',cyan:'#67e8f9' },
          600: { red:'#fca5a5',green:'#86efac',blue:'#93c5fd',yellow:'#fde047',purple:'#d8b4fe',orange:'#fdba74',pink:'#f9a8d4',cyan:'#67e8f9' },
          700: { red:'#f87171',green:'#4ade80',blue:'#60a5fa',yellow:'#facc15',purple:'#c084fc',orange:'#fb923c',pink:'#f472b6',cyan:'#22d3ee' }
        },
        dark: {
          300: { red:'#ef4444',green:'#22c55e',blue:'#3b82f6',yellow:'#eab308',purple:'#a855f7',orange:'#f97316',pink:'#ec4899',cyan:'#06b6d4' },
          400: { red:'#dc2626',green:'#16a34a',blue:'#2563eb',yellow:'#ca8a04',purple:'#9333ea',orange:'#ea580c',pink:'#db2777',cyan:'#0891b2' },
          500: { red:'#b91c1c',green:'#15803d',blue:'#1d4ed8',yellow:'#a16207',purple:'#7e22ce',orange:'#c2410c',pink:'#be185d',cyan:'#0e7490' },
          600: { red:'#991b1b',green:'#166534',blue:'#1e40af',yellow:'#854d0e',purple:'#6b21a8',orange:'#9a3412',pink:'#9d174d',cyan:'#155e75' },
          700: { red:'#7f1d1d',green:'#14532d',blue:'#1e3a8a',yellow:'#713f12',purple:'#581c87',orange:'#7c2d12',pink:'#831843',cyan:'#164e63' }
        }
      },
      material: {
        light: {
          300: { red:'#ffcdd2',green:'#c8e6c9',blue:'#bbdefb',yellow:'#fff9c4',purple:'#e1bee7',orange:'#ffe0b2',pink:'#f8bbd0',cyan:'#b2ebf2' },
          400: { red:'#ef9a9a',green:'#a5d6a7',blue:'#90caf9',yellow:'#fff59d',purple:'#ce93d8',orange:'#ffcc80',pink:'#f48fb1',cyan:'#80deea' },
          500: { red:'#e57373',green:'#81c784',blue:'#64b5f6',yellow:'#fff176',purple:'#ba68c8',orange:'#ffb74d',pink:'#f06292',cyan:'#4dd0e1' },
          600: { red:'#e57373',green:'#81c784',blue:'#64b5f6',yellow:'#fff176',purple:'#ba68c8',orange:'#ffb74d',pink:'#f06292',cyan:'#4dd0e1' },
          700: { red:'#ef5350',green:'#66bb6a',blue:'#42a5f5',yellow:'#ffee58',purple:'#ab47bc',orange:'#ffa726',pink:'#ec407a',cyan:'#26c6da' }
        },
        dark: {
          300: { red:'#f44336',green:'#4caf50',blue:'#2196f3',yellow:'#ffeb3b',purple:'#9c27b0',orange:'#ff9800',pink:'#e91e63',cyan:'#00bcd4' },
          400: { red:'#e53935',green:'#43a047',blue:'#1e88e5',yellow:'#fdd835',purple:'#8e24aa',orange:'#fb8c00',pink:'#d81b60',cyan:'#00acc1' },
          500: { red:'#d32f2f',green:'#388e3c',blue:'#1976d2',yellow:'#fbc02d',purple:'#7b1fa2',orange:'#f57c00',pink:'#c2185b',cyan:'#0097a7' },
          600: { red:'#c62828',green:'#2e7d32',blue:'#1565c0',yellow:'#f9a825',purple:'#6a1b9a',orange:'#ef6c00',pink:'#ad1457',cyan:'#00838f' },
          700: { red:'#b71c1c',green:'#1b5e20',blue:'#0d47a1',yellow:'#f57f17',purple:'#4a148c',orange:'#e65100',pink:'#880e4f',cyan:'#006064' }
        }
      }
    };

    // Default palette config per theme
    const paletteDefaults = {
      light: { set: 'tailwind', shade: 400 },
      dark: { set: 'tailwind', shade: 600 }
    };

    // Build the active colorPalette from set + shade
    let colorPalette = {};
    function buildColorPalette(setName, shade) {
      const colors = paletteSets[setName]?.[shade];
      if (!colors) return;
      const lightVariants = paletteVariants[setName]?.light?.[shade] || {};
      const darkVariants = paletteVariants[setName]?.dark?.[shade] || {};

      colorPalette = {
        // Main colors from palette
        ...colors,
        // Neutrals (theme-independent)
        gray: '#90a4ae', slate: '#78909c', zinc: '#a1a1aa', stone: '#a1887f',
        // Special
        brown: '#8d6e63', black: '#18181b', white: '#fafafa',
        // Light variants
        'light-red': lightVariants.red || colors.red,
        'light-green': lightVariants.green || colors.green,
        'light-blue': lightVariants.blue || colors.blue,
        'light-yellow': lightVariants.yellow || colors.yellow,
        'light-purple': lightVariants.purple || colors.purple,
        'light-pink': lightVariants.pink || colors.pink,
        'light-orange': lightVariants.orange || colors.orange,
        'light-cyan': lightVariants.cyan || colors.cyan,
        // Dark variants
        'dark-red': darkVariants.red || colors.red,
        'dark-green': darkVariants.green || colors.green,
        'dark-blue': darkVariants.blue || colors.blue,
        'dark-purple': darkVariants.purple || colors.purple,
        'dark-orange': darkVariants.orange || colors.orange
      };
    }

    // Initialize with dark theme default (matches state.theme = 'dark')
    buildColorPalette(paletteDefaults.dark.set, paletteDefaults.dark.shade);

    // ============================================
    // LocalStorage Persistence
    // ============================================

    const STORAGE_KEY = 'flowscript_demo_files_v2';
    const VERSIONS_KEY = 'flowscript_versions_v1';

    // Version storage: { filename: [{ id, timestamp, comment, content }, ...] }
    let fileVersions = {};

    function loadVersions() {
      try {
        const saved = localStorage.getItem(VERSIONS_KEY);
        if (saved) {
          fileVersions = JSON.parse(saved);
        }
      } catch (e) {
        console.warn('Failed to load versions:', e);
        fileVersions = {};
      }
    }

    function saveVersions() {
      try {
        localStorage.setItem(VERSIONS_KEY, JSON.stringify(fileVersions));
      } catch (e) {
        console.warn('Failed to save versions:', e);
      }
    }

    function getFileVersions(filename) {
      return fileVersions[filename] || [];
    }

    function addVersion(filename, content, comment) {
      if (!fileVersions[filename]) {
        fileVersions[filename] = [];
      }
      
      const version = {
        id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
        timestamp: Date.now(),
        comment: comment || 'Auto-save',
        content: content
      };
      
      fileVersions[filename].unshift(version); // Add to beginning
      
      // Keep only last 50 versions per file
      if (fileVersions[filename].length > 50) {
        fileVersions[filename] = fileVersions[filename].slice(0, 50);
      }
      
      saveVersions();
      return version;
    }

    function deleteVersion(filename, versionId) {
      if (!fileVersions[filename]) return;
      fileVersions[filename] = fileVersions[filename].filter(v => v.id !== versionId);
      saveVersions();
    }

    function formatVersionTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);
      
      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays < 7) return `${diffDays}d ago`;
      
      return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined });
    }

    function formatFullTime(timestamp) {
      return new Date(timestamp).toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });
    }

    // Auto-save timer
    let autoSaveTimer = null;
    let lastAutoSaveContent = '';

    function scheduleAutoSave() {
      if (autoSaveTimer) clearTimeout(autoSaveTimer);
      
      autoSaveTimer = setTimeout(() => {
        if (state.currentFile && state.demoMode) {
          const currentContent = editor.value;
          const fileData = state.files.get(state.currentFile);
          
          // Only auto-save if content actually changed significantly
          if (fileData && currentContent !== lastAutoSaveContent && currentContent.length > 10) {
            // Check if last version is recent (within 5 minutes) and auto-save
            const versions = getFileVersions(state.currentFile);
            const lastVersion = versions[0];
            const fiveMinutes = 5 * 60 * 1000;
            
            if (!lastVersion || Date.now() - lastVersion.timestamp > fiveMinutes) {
              addVersion(state.currentFile, currentContent, 'Auto-save');
              lastAutoSaveContent = currentContent;
            }
          }
        }
      }, 30000); // Auto-save after 30 seconds of inactivity
    }

    function saveToLocalStorage() {
      if (!state.demoMode) return;
      
      const data = {};
      state.files.forEach((fileData, name) => {
        data[name] = {
          content: fileData.content,
          lastUpdated: fileData.lastUpdated
        };
      });
      
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          files: data,
          currentFile: state.currentFile,
          sortBy: state.sortBy,
          theme: state.theme,
          palette: state.palette
        }));
      } catch (e) {
        console.warn('Failed to save to localStorage:', e);
      }
    }

    function loadFromLocalStorage() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const data = JSON.parse(saved);
          if (data.files && Object.keys(data.files).length > 0) {
            return data;
          }
        }
      } catch (e) {
        console.warn('Failed to load from localStorage:', e);
      }
      return null;
    }

    // ============================================
    // File System Functions
    // ============================================

    async function openFolder() {
      if (!hasFileSystemAccess) {
        showToast('Your browser does not support local file access. Try Chrome or Edge.');
        return;
      }

      try {
        state.directoryHandle = await window.showDirectoryPicker({
          mode: 'readwrite'
        });
        
        document.getElementById('projectLabel').innerHTML = `<strong>${state.directoryHandle.name}</strong>`;
        
        // Show project UI
        document.getElementById('noProjectState').style.display = 'none';
        document.getElementById('sidebar').style.display = 'flex';
        document.getElementById('sidebarResize').style.display = 'block';
        document.getElementById('editorPanel').style.display = 'flex';
        document.getElementById('editorResize').style.display = 'block';
        document.getElementById('canvasPanel').style.display = 'block';
        
        state.demoMode = false;
        await refreshFileTree();
        updateGrid();
        setupSortListeners();
        
        showToast(`Opened: ${state.directoryHandle.name}`);
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error(err);
          showToast('Failed to open folder');
        }
      }
    }

    async function refreshFileTree() {
      if (!state.directoryHandle) return;
      
      state.files.clear();

      for await (const entry of state.directoryHandle.values()) {
        if (entry.kind === 'file' && entry.name.endsWith('.flow')) {
          // Get file metadata for lastModified
          const file = await entry.getFile();
          state.files.set(entry.name, { 
            handle: entry, 
            content: null, 
            modified: false,
            lastUpdated: file.lastModified
          });
        }
      }

      // Get sorted files
      const sortedFiles = getSortedFiles();

      // Render file tree
      if (sortedFiles.length === 0) {
        fileTree.innerHTML = `
          <div class="empty-state">
            <p>No .flow files yet</p>
            <button class="btn" onclick="showNewFileModal()">Create first file</button>
          </div>
        `;
      } else {
        fileTree.innerHTML = sortedFiles.map(name => {
          const fileData = state.files.get(name);
          const timeAgo = fileData?.lastUpdated ? getTimeAgo(fileData.lastUpdated) : '';
          return `
          <div class="file-item ${state.currentFile === name ? 'active' : ''} ${fileData?.modified ? 'modified' : ''}" data-file="${name}">
            <svg class="file-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z"/>
              <path d="M14 2v6h6"/>
            </svg>
            <span class="file-name">${name}</span>
            ${state.sortBy === 'recent' && timeAgo && !fileData?.modified ? `<span class="file-time">${timeAgo}</span>` : ''}
            <button class="file-delete-btn" data-delete="${name}" title="Delete file">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3,6 5,6 21,6"/>
                <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
              </svg>
            </button>
          </div>
        `}).join('');

        // Add click handlers
        fileTree.querySelectorAll('.file-item').forEach(item => {
          item.addEventListener('click', (e) => {
            if (e.target.closest('.file-delete-btn')) return;
            openFile(item.dataset.file);
          });
        });

        fileTree.querySelectorAll('.file-delete-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const filename = btn.dataset.delete;
            showDeleteConfirmation(filename);
          });
        });

        // Open first file if none selected
        if (!state.currentFile && sortedFiles.length > 0) {
          openFile(sortedFiles[0]);
        }
      }
    }

    async function openFile(filename) {
      if (!state.files.has(filename)) return;
      
      // Save current file if modified
      if (state.currentFile && state.files.get(state.currentFile)?.modified) {
        await saveCurrentFile();
      }

      const fileData = state.files.get(filename);
      
      // Read content if not cached
      if (fileData.content === null) {
        try {
          const file = await fileData.handle.getFile();
          fileData.content = await file.text();
        } catch (err) {
          console.error(err);
          showToast('Failed to read file');
          return;
        }
      }

      state.currentFile = filename;
      editor.value = fileData.content;
      document.getElementById('currentFileName').textContent = filename;
      
      // Update UI
      fileTree.querySelectorAll('.file-item').forEach(item => {
        item.classList.toggle('active', item.dataset.file === filename);
      });

      updateDiagram();
      updateSaveStatus();
    }

    async function saveCurrentFile() {
      if (!state.currentFile || !state.directoryHandle) return;

      const fileData = state.files.get(state.currentFile);
      if (!fileData) return;

      try {
        const writable = await fileData.handle.createWritable();
        await writable.write(editor.value);
        await writable.close();
        
        fileData.content = editor.value;
        fileData.modified = false;
        
        updateSaveStatus();
        showToast('Saved');
      } catch (err) {
        console.error(err);
        showToast('Failed to save file');
      }
    }

    async function createNewFile(filename) {
      if (!state.directoryHandle) return;
      
      // Ensure .flow extension
      if (!filename.endsWith('.flow')) {
        filename += '.flow';
      }

      // Check if exists
      if (state.files.has(filename)) {
        showToast('File already exists');
        return;
      }

      try {
        const handle = await state.directoryHandle.getFileHandle(filename, { create: true });
        
        const defaultContent = `// ${filename.replace('.flow', '')}

Start [shape: oval]
Process
End [shape: oval]

Start > Process
Process > End`;

        const writable = await handle.createWritable();
        await writable.write(defaultContent);
        await writable.close();

        state.files.set(filename, { handle, content: defaultContent, modified: false });
        
        await refreshFileTree();
        openFile(filename);
        
        showToast('File created');
      } catch (err) {
        console.error(err);
        showToast('Failed to create file');
      }
    }

    async function deleteCurrentFile() {
      if (!state.currentFile || !state.directoryHandle) return;

      try {
        await state.directoryHandle.removeEntry(state.currentFile);
        state.files.delete(state.currentFile);
        state.currentFile = null;
        editor.value = '';
        canvas.innerHTML = '';
        
        await refreshFileTree();
        showToast('File deleted');
      } catch (err) {
        console.error(err);
        showToast('Failed to delete file');
      }
    }

    function showNewFileModal() {
      document.getElementById('newFileInput').value = '';
      document.getElementById('newFileModal').classList.add('active');
      document.getElementById('newFileInput').focus();
    }

    function updateSaveStatus() {
      const fileData = state.currentFile ? state.files.get(state.currentFile) : null;
      
      if (fileData?.modified) {
        saveStatus.textContent = 'Modified';
        statusDot.classList.add('modified');
        statusDot.classList.remove('error');
      } else {
        saveStatus.textContent = 'Saved';
        statusDot.classList.remove('modified', 'error');
      }
    }

    // ============================================
    // Parser (Eraser.io compatible syntax)
    // ============================================

    function parse(source) {
      const nodes = new Map();
      const edges = [];
      const groups = [];
      const groupNames = new Set();
      let direction = 'down';
      
      // Tokenize with brace matching for groups
      const tokens = tokenize(source);
      
      // Parse tokens
      parseTokens(tokens, nodes, edges, groups, groupNames, null);
      
      // Extract direction from source
      const dirMatch = source.match(/direction\s+(down|up|left|right|top|bottom)/i);
      if (dirMatch) {
        const d = dirMatch[1].toLowerCase();
        // Aliases: top = down (top-to-bottom), bottom = up (bottom-to-top)
        direction = d === 'top' ? 'down' : d === 'bottom' ? 'up' : d;
      }

      return { nodes: Array.from(nodes.values()), edges, groups, groupNames, direction };
    }

    function tokenize(source) {
      const lines = source.split('\n');
      const tokens = [];
      let i = 0;
      
      while (i < lines.length) {
        const line = lines[i];
        const trimmed = line.trim();
        
        // Skip empty lines and comments
        if (!trimmed || trimmed.startsWith('//')) {
          i++;
          continue;
        }
        
        // Skip direction/style directives
        if (/^(direction|colorMode|styleMode|typeface)\s+/i.test(trimmed)) {
          i++;
          continue;
        }
        
        // Check if this line starts a group (has { at end or followed by {)
        if (trimmed.includes('{') && !hasConnectorChar(trimmed)) {
          const result = parseGroupBlock(lines, i);
          tokens.push(result.token);
          i = result.nextIndex;
          continue;
        }

        // Connection line
        if (hasConnectorChar(trimmed) || trimmed.match(/\s-\s/) || trimmed.includes('--')) {
          tokens.push({ type: 'connection', content: trimmed });
          i++;
          continue;
        }
        
        // Node definition (possibly multiple comma-separated)
        tokens.push({ type: 'nodes', content: trimmed });
        i++;
      }
      
      return tokens;
    }

    function parseGroupBlock(lines, startIndex) {
      const firstLine = lines[startIndex].trim();
      let braceCount = 0;
      let content = [];
      let i = startIndex;
      
      // Get group name and properties from first line
      const headerMatch = firstLine.match(/^(.+?)\s*(\[.*?\])?\s*\{(.*)$/);
      let groupName = headerMatch ? headerMatch[1].trim() : firstLine.replace(/\s*\{.*$/, '').trim();
      let propsStr = headerMatch ? headerMatch[2] || '' : '';
      let restOfLine = headerMatch ? headerMatch[3] || '' : '';
      
      // Handle quoted names
      if (groupName.startsWith('"') && groupName.endsWith('"')) {
        groupName = groupName.slice(1, -1);
      }
      
      // Count braces in first line
      for (const ch of firstLine) {
        if (ch === '{') braceCount++;
        if (ch === '}') braceCount--;
      }
      
      // If there's content after { on same line
      if (restOfLine.trim() && !restOfLine.trim().startsWith('}')) {
        content.push(restOfLine.trim().replace(/\}$/, ''));
      }
      
      i++;
      
      // Collect content until braces balance
      while (i < lines.length && braceCount > 0) {
        const line = lines[i].trim();
        for (const ch of line) {
          if (ch === '{') braceCount++;
          if (ch === '}') braceCount--;
        }
        if (braceCount > 0) {
          content.push(line);
        } else {
          // Last line, remove trailing }
          const lastContent = line.replace(/\}$/, '').trim();
          if (lastContent) content.push(lastContent);
        }
        i++;
      }
      
      return {
        token: {
          type: 'group',
          name: groupName,
          props: propsStr,
          content: content.join('\n')
        },
        nextIndex: i
      };
    }

    function parseTokens(tokens, nodes, edges, groups, groupNames, parentGroup) {
      for (const token of tokens) {
        if (token.type === 'group') {
          const props = parseProperties(token.props);
          const group = {
            name: token.name,
            color: props.color ? (colorPalette[props.color] || props.color) : null,
            icon: props.icon,
            label: props.label || token.name,
            children: []
          };
          groups.push(group);
          groupNames.add(token.name);
          
          // Parse group content recursively
          const innerTokens = tokenize(token.content);
          parseTokens(innerTokens, nodes, edges, groups, groupNames, group);
          
        } else if (token.type === 'connection') {
          parseConnection(token.content, nodes, edges, groupNames);
          
        } else if (token.type === 'nodes') {
          // Could be comma-separated nodes
          const nodeStrs = splitOutsideBrackets(token.content, ',');
          for (const nodeStr of nodeStrs) {
            const node = parseNode(nodeStr.trim());
            if (node && !nodes.has(node.id)) {
              if (parentGroup) {
                node.group = parentGroup.name;
                parentGroup.children.push(node.id);
              }
              nodes.set(node.id, node);
            }
          }
        }
      }
    }

    function parseProperties(propsStr) {
      const props = {};
      if (!propsStr) return props;
      
      // Remove brackets
      const inner = propsStr.replace(/^\[|\]$/g, '').trim();
      if (!inner) return props;
      
      // Split by comma, but respect quoted values
      const parts = splitOutsideBrackets(inner, ',');
      
      for (const part of parts) {
        const colonIdx = part.indexOf(':');
        if (colonIdx > -1) {
          const key = part.slice(0, colonIdx).trim().toLowerCase();
          let value = part.slice(colonIdx + 1).trim();
          // Remove quotes from value
          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.slice(1, -1);
          }
          props[key] = value;
        }
      }
      
      return props;
    }

    function hasConnectorChar(text) {
      // Returns true if text contains < or > outside of [...] brackets
      let depth = 0;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (ch === '[') depth++;
        else if (ch === ']') depth--;
        else if (depth === 0 && (ch === '>' || ch === '<')) return true;
      }
      return false;
    }

    function splitConnector(text, connector) {
      // Split text by connector string, but only outside of [...] brackets
      const parts = [];
      let current = '';
      let depth = 0;
      const len = connector.length;
      for (let i = 0; i < text.length; ) {
        const ch = text[i];
        if (ch === '[') depth++;
        else if (ch === ']') depth--;
        if (depth === 0 && text.slice(i, i + len) === connector) {
          parts.push(current.trim());
          current = '';
          i += len;
        } else {
          current += ch;
          i++;
        }
      }
      parts.push(current.trim());
      return parts;
    }

    function splitOutsideBrackets(str, delimiter) {
      const result = [];
      let current = '';
      let depth = 0;
      let inQuotes = false;
      
      for (let i = 0; i < str.length; i++) {
        const ch = str[i];
        
        if (ch === '"' && str[i-1] !== '\\') {
          inQuotes = !inQuotes;
        }
        
        if (!inQuotes) {
          if (ch === '[' || ch === '{') depth++;
          if (ch === ']' || ch === '}') depth--;
        }
        
        if (ch === delimiter && depth === 0 && !inQuotes) {
          result.push(current.trim());
          current = '';
        } else {
          current += ch;
        }
      }
      
      if (current.trim()) result.push(current.trim());
      return result;
    }

    function parseNode(text) {
      let remaining = text.trim();
      if (!remaining) return null;
      
      // Extract properties [key: value, ...]
      const propsMatch = remaining.match(/\[([^\]]+)\]/);
      const props = propsMatch ? parseProperties(`[${propsMatch[1]}]`) : {};
      remaining = remaining.replace(/\[[^\]]+\]/, '').trim();
      
      // Handle quoted names
      let id = remaining;
      if (id.startsWith('"') && id.endsWith('"')) {
        id = id.slice(1, -1);
      }
      
      if (!id) return null;
      
      // Map shape property to internal shape
      const shape = props.shape ? props.shape.toLowerCase() : 'rectangle';
      const shapeInfo = shapeMap[shape] || shapeMap.default;
      
      // Resolve color
      let color = null;
      if (props.color) {
        color = colorPalette[props.color] || props.color;
        // Handle hex in quotes
        if (color.startsWith('"')) color = color.replace(/"/g, '');
      }
      
      // Text mode: wrap (default), fit, clip
      const textMode = props.text ? props.text.toLowerCase() : 'wrap';
      
      return {
        id,
        label: props.label || id,
        shape: shapeInfo.shape,
        shapeRadius: shapeInfo.radius,
        color,
        icon: props.icon,
        text: textMode,
        group: null
      };
    }

    function parseConnection(text, nodes, edges, groupNames) {
      // Handle different connector types: >, <, <>, -, --, -->
      // First, extract any trailing properties [color: x]
      let edgeProps = {};
      const propsMatch = text.match(/\[([^\]]+)\]\s*$/);
      if (propsMatch) {
        edgeProps = parseProperties(`[${propsMatch[1]}]`);
        text = text.replace(/\[[^\]]+\]\s*$/, '').trim();
      }
      
      // Determine connector type using the definition part (before any label separator)
      // so that < or > inside an edge label don't confuse connector detection
      const firstColonIdx = text.indexOf(':');
      const connDef = firstColonIdx >= 0 ? text.slice(0, firstColonIdx) : text;

      let connectorType = '>';
      let parts = [];

      if (connDef.includes('<>')) {
        connectorType = '<>';
        parts = splitConnector(text, '<>');
      } else if (connDef.includes('-->')) {
        connectorType = '-->';
        parts = splitConnector(text, '-->');
      } else if (connDef.includes('--')) {
        connectorType = '--';
        parts = splitConnector(text, '--');
      } else if (connDef.includes('<') && !connDef.includes('>')) {
        connectorType = '<';
        parts = splitConnector(text, '<');
      } else if (connDef.includes('>')) {
        connectorType = '>';
        parts = splitConnector(text, '>');
      } else if (text.match(/\s-\s/)) {
        connectorType = '-';
        parts = text.split(/\s-\s/).map(p => p.trim());
      }

      if (parts.length < 2) return;

      // Process chained connections: A > B > C
      let stopProcessing = false;
      for (let i = 0; i < parts.length - 1 && !stopProcessing; i++) {
        let sourcePart = parts[i];
        let targetPart = parts[i + 1];

        // Source could have been created from previous iteration
        // Handle branching: A > B, C, D (only on last part)
        const targets = (i === parts.length - 2) ? splitOutsideBrackets(targetPart, ',') : [targetPart];

        for (let target of targets) {
          let label = '';

          // Extract label after colon: A > B: label
          const colonMatch = target.match(/^(.+?):\s*(.*)$/);
          if (colonMatch) {
            target = colonMatch[1].trim();
            label = colonMatch[2].trim();
            // If there are more connector-split parts after this target, they belong to
            // the label (e.g. "A > B: x > y" should give label "x > y", not a new node "y")
            if (i + 2 < parts.length) {
              const remaining = parts.slice(i + 2).join(connectorType);
              label = label ? (label + connectorType + remaining) : remaining;
              stopProcessing = true;
            }
            // Remove any trailing properties from label
            label = label.replace(/\[[^\]]+\]$/, '').trim();
          }

          // Clean source and target IDs
          const sourceId = extractNodeId(sourcePart);
          const targetId = extractNodeId(target);

          // Ensure nodes exist
          const sourceIsGroup = groupNames.has(sourceId);
          const targetIsGroup = groupNames.has(targetId);

          if (!sourceIsGroup && !nodes.has(sourceId)) {
            const node = parseNode(sourcePart);
            if (node) nodes.set(sourceId, node);
          }
          if (!targetIsGroup && !nodes.has(targetId)) {
            const node = parseNode(target);
            if (node) nodes.set(targetId, node);
          }

          // Resolve edge color
          let edgeColor = null;
          if (edgeProps.color) {
            edgeColor = colorPalette[edgeProps.color] || edgeProps.color;
          }

          edges.push({
            source: sourceId,
            target: targetId,
            label,
            connectorType,
            color: edgeColor,
            sourceIsGroup,
            targetIsGroup
          });
        }

        // For chained connections, use target as next source
        sourcePart = targets[0];
      }
    }

    function extractNodeId(text) {
      // Remove properties and quotes
      let id = text.replace(/\[[^\]]+\]/g, '').trim();
      if (id.startsWith('"') && id.endsWith('"')) {
        id = id.slice(1, -1);
      }
      return id;
    }

    // ============================================
    // Layout
    // ============================================

    async function layout(parsed) {
      const nodeToGroup = new Map();
      const groupNameToIdx = new Map();

      parsed.groups.forEach((g, idx) => {
        groupNameToIdx.set(g.name, idx);
        g.children.forEach(id => nodeToGroup.set(id, idx));
      });

      const autoNodes = parsed.nodes.filter(n => !n.position);

      // Detect if any group has re-entrant flows (chain leaves and re-enters same group).
      // This requires flat layout; otherwise hierarchical ELK groups work fine.
      const hasReentrantFlows = (() => {
        const groupEntries = new Map(); // groupIdx -> Set of nodes that have incoming cross-group edges
        const groupExits = new Map();   // groupIdx -> Set of nodes that have outgoing cross-group edges
        parsed.edges.forEach(e => {
          if (e.sourceIsGroup || e.targetIsGroup) return;
          const sGroup = nodeToGroup.get(e.source);
          const tGroup = nodeToGroup.get(e.target);
          if (sGroup !== undefined && tGroup !== undefined && sGroup !== tGroup) {
            if (!groupExits.has(sGroup)) groupExits.set(sGroup, new Set());
            groupExits.get(sGroup).add(e.source);
            if (!groupEntries.has(tGroup)) groupEntries.set(tGroup, new Set());
            groupEntries.get(tGroup).add(e.target);
          }
        });
        // A group is re-entrant if it has BOTH exits and entries
        for (const [gIdx] of groupExits) {
          if (groupEntries.has(gIdx)) return true;
        }
        return false;
      })();

      // Map direction to ELK direction
      const directionMap = {
        down: 'DOWN',
        up: 'UP',
        right: 'RIGHT',
        left: 'LEFT'
      };
      const elkDirection = directionMap[parsed.direction] || 'DOWN';

      parsed._dummyEdgeIds = new Set();
      parsed._edgeMeta = new Map(); // edgeId -> { connectorType, color }

      if (hasReentrantFlows) {
        return await layoutFlat(parsed, autoNodes, nodeToGroup, groupNameToIdx, elkDirection);
      } else {
        return await layoutHierarchical(parsed, autoNodes, nodeToGroup, groupNameToIdx, elkDirection);
      }
    }

    // Side-by-side layout for re-entrant group flows.
    // Layouts each group independently, then positions satellite groups beside the
    // primary (re-entrant) group, aligned vertically with their connection points.
    async function layoutFlat(parsed, autoNodes, nodeToGroup, groupNameToIdx, elkDirection) {
      const groupPadding = { top: 35, left: 15, bottom: 15, right: 15 };
      const groupSpacing = 40;

      // Identify the primary group (the one with both exits and entries)
      const groupExitNodes = new Map();  // groupIdx -> [nodeId]
      const groupEntryNodes = new Map(); // groupIdx -> [nodeId]
      parsed.edges.forEach(e => {
        if (e.sourceIsGroup || e.targetIsGroup) return;
        const sGroup = nodeToGroup.get(e.source);
        const tGroup = nodeToGroup.get(e.target);
        if (sGroup !== undefined && tGroup !== undefined && sGroup !== tGroup) {
          if (!groupExitNodes.has(sGroup)) groupExitNodes.set(sGroup, []);
          groupExitNodes.get(sGroup).push(e.source);
          if (!groupEntryNodes.has(tGroup)) groupEntryNodes.set(tGroup, []);
          groupEntryNodes.get(tGroup).push(e.target);
        }
      });

      let primaryGroupIdx = -1;
      for (const [gIdx] of groupExitNodes) {
        if (groupEntryNodes.has(gIdx)) { primaryGroupIdx = gIdx; break; }
      }

      // Trace re-entry: for an exit node, follow the chain until we re-enter the same group
      function traceReentry(exitNode, exitGroup) {
        let current = exitNode;
        const visited = new Set();
        while (true) {
          visited.add(current);
          const nextEdge = parsed.edges.find(e => e.source === current && !visited.has(e.target));
          if (!nextEdge) return null;
          const nextGroup = nodeToGroup.get(nextEdge.target);
          if (nextGroup === exitGroup) return nextEdge.target;
          current = nextEdge.target;
          if (visited.size > 100) return null;
        }
      }

      // Layout primary group internally with dummy ordering edges
      const primaryNodes = autoNodes.filter(n => nodeToGroup.get(n.id) === primaryGroupIdx);
      const primaryEdges = parsed.edges
        .filter(e => nodeToGroup.get(e.source) === primaryGroupIdx && nodeToGroup.get(e.target) === primaryGroupIdx && !e.sourceIsGroup && !e.targetIsGroup);

      // Add dummy ordering edges for chain continuity within the primary group
      const dummyEdges = [];
      if (groupExitNodes.has(primaryGroupIdx)) {
        for (const exitNode of groupExitNodes.get(primaryGroupIdx)) {
          const reentry = traceReentry(exitNode, primaryGroupIdx);
          if (reentry) dummyEdges.push({ source: exitNode, target: reentry });
        }
      }

      const primaryElkEdges = primaryEdges.map((e, i) => {
        const edgeId = `pe_${i}`;
        parsed._edgeMeta.set(edgeId, { connectorType: e.connectorType, color: e.color });
        return {
          id: edgeId,
          sources: [e.source],
          targets: [e.target],
          labels: e.label ? [calculateEdgeLabelDimensions(e.label)] : []
        };
      });
      dummyEdges.forEach((d, i) => {
        const edgeId = `__dummy_p_${i}`;
        parsed._dummyEdgeIds.add(edgeId);
        primaryElkEdges.push({ id: edgeId, sources: [d.source], targets: [d.target] });
      });

      const primaryResult = await elk.layout({
        id: 'primary',
        layoutOptions: {
          'elk.algorithm': 'layered',
          'elk.direction': elkDirection,
          'elk.spacing.nodeNode': '30',
          'elk.layered.spacing.nodeNodeBetweenLayers': '28',
          'elk.edgeRouting': 'ORTHOGONAL',
          'elk.edgeLabels.placement': 'CENTER',
          'elk.edgeLabels.inline': 'true',
          'elk.spacing.edgeLabel': '2',
          'elk.spacing.edgeNode': '5',
          'elk.spacing.labelNode': '2'
        },
        children: primaryNodes.map(n => createElkNode(n)),
        edges: primaryElkEdges
      });

      // Build a map of node positions within the primary group (relative to group origin)
      const primaryNodePos = new Map();
      (primaryResult.children || []).forEach(c => {
        primaryNodePos.set(c.id, { x: c.x, y: c.y, width: c.width, height: c.height });
      });

      // Layout each satellite group independently
      const satelliteResults = new Map(); // groupIdx -> elkResult
      for (const [gIdx, group] of parsed.groups.entries()) {
        if (gIdx === primaryGroupIdx) continue;
        const nodes = autoNodes.filter(n => nodeToGroup.get(n.id) === gIdx);
        if (!nodes.length) continue;
        const edges = parsed.edges
          .filter(e => nodeToGroup.get(e.source) === gIdx && nodeToGroup.get(e.target) === gIdx && !e.sourceIsGroup && !e.targetIsGroup);
        const satResult = await elk.layout({
          id: `sat_${gIdx}`,
          layoutOptions: {
            'elk.algorithm': 'layered',
            'elk.direction': elkDirection,
            'elk.spacing.nodeNode': '30',
            'elk.layered.spacing.nodeNodeBetweenLayers': '20',
            'elk.edgeRouting': 'ORTHOGONAL',
            'elk.edgeLabels.placement': 'CENTER',
            'elk.edgeLabels.inline': 'true',
            'elk.spacing.edgeLabel': '2',
            'elk.spacing.edgeNode': '5',
            'elk.spacing.labelNode': '2'
          },
          children: nodes.map(n => createElkNode(n)),
          edges: edges.map((e, i) => {
            const edgeId = `se_${gIdx}_${i}`;
            parsed._edgeMeta.set(edgeId, { connectorType: e.connectorType, color: e.color });
            return {
              id: edgeId,
              sources: [e.source],
              targets: [e.target],
              labels: e.label ? [calculateEdgeLabelDimensions(e.label)] : []
            };
          })
        });
        satelliteResults.set(gIdx, satResult);
      }

      // Position groups: primary group on the left, satellite groups to the right
      // Satellite groups are vertically aligned with the exit node in the primary group
      const primaryGx = groupPadding.left;
      const primaryGy = groupPadding.top;
      const primaryWidth = primaryResult.width || 200;
      const primaryHeight = primaryResult.height || 200;

      // For each satellite group, find the vertical position of the exit node that connects to it
      // Then resolve overlaps so groups don't stack on top of each other
      const satellitePositions = new Map(); // groupIdx -> { x, y }

      // Collect satellite info in edge order (preserves top-to-bottom flow)
      const satelliteOrder = [];
      parsed.edges.forEach(e => {
        if (e.sourceIsGroup || e.targetIsGroup) return;
        const sGroup = nodeToGroup.get(e.source);
        const tGroup = nodeToGroup.get(e.target);
        if (sGroup === primaryGroupIdx && tGroup !== undefined && tGroup !== primaryGroupIdx) {
          if (satellitePositions.has(tGroup)) return; // already seen
          const exitNodePos = primaryNodePos.get(e.source);
          if (!exitNodePos) return;
          const satResult = satelliteResults.get(tGroup);
          if (!satResult) return;
          const satWidth = satResult.width || 200;
          const satHeight = satResult.height || 200;
          const totalH = satHeight + groupPadding.top + groupPadding.bottom;

          // Ideal position: center satellite on the exit node
          const sx = primaryGx + primaryWidth + groupPadding.left + groupPadding.right + groupSpacing;
          const idealY = primaryGy + exitNodePos.y + groupPadding.top + exitNodePos.height / 2 - totalH / 2;

          satelliteOrder.push({ gIdx: tGroup, x: sx, idealY, height: totalH });
          satellitePositions.set(tGroup, true); // mark as seen
        }
      });

      // Resolve overlaps: push each satellite down if it overlaps the previous one
      // Use consistent spacing between groups
      let prevBottom = -Infinity;
      for (const sat of satelliteOrder) {
        let y = sat.idealY;
        if (y < prevBottom + groupSpacing) {
          y = prevBottom + groupSpacing;
        }
        satellitePositions.set(sat.gIdx, { x: sat.x, y });
        prevBottom = y + sat.height;
      }

      // Build the combined result in ELK format expected by the renderer
      const allChildren = [];

      // Primary group container
      const primaryRebasedChildren = (primaryResult.children || []).map(c => ({
        ...c,
        x: c.x,
        y: c.y
      }));
      // Primary group internal edges (for the renderer to draw)
      const primaryGroupEdges = (primaryResult.edges || []).map(e => ({
        ...e,
        sections: (e.sections || []).map(s => ({
          ...s
        }))
      }));

      allChildren.push({
        id: `__group_${primaryGroupIdx}`,
        x: primaryGx,
        y: primaryGy,
        width: primaryWidth + groupPadding.left + groupPadding.right,
        height: primaryHeight + groupPadding.top + groupPadding.bottom,
        children: primaryRebasedChildren.map(c => ({
          ...c,
          x: c.x + groupPadding.left,
          y: c.y + groupPadding.top
        })),
        edges: primaryGroupEdges.map(e => ({
          ...e,
          sections: (e.sections || []).map(s => ({
            startPoint: { x: s.startPoint.x + groupPadding.left, y: s.startPoint.y + groupPadding.top },
            endPoint: { x: s.endPoint.x + groupPadding.left, y: s.endPoint.y + groupPadding.top },
            bendPoints: (s.bendPoints || []).map(b => ({ x: b.x + groupPadding.left, y: b.y + groupPadding.top }))
          })),
          labels: (e.labels || []).map(l => l.x !== undefined ? { ...l, x: l.x + groupPadding.left, y: l.y + groupPadding.top } : l)
        }))
      });

      // Satellite group containers
      for (const [gIdx, satResult] of satelliteResults) {
        const pos = satellitePositions.get(gIdx) || { x: primaryGx + primaryWidth + groupSpacing + 50, y: 0 };
        const satWidth = satResult.width || 200;
        const satHeight = satResult.height || 200;
        const satRebasedChildren = (satResult.children || []).map(c => ({
          ...c,
          x: c.x + groupPadding.left,
          y: c.y + groupPadding.top
        }));
        const satGroupEdges = (satResult.edges || []).map(e => ({
          ...e,
          sections: (e.sections || []).map(s => ({
            startPoint: { x: s.startPoint.x + groupPadding.left, y: s.startPoint.y + groupPadding.top },
            endPoint: { x: s.endPoint.x + groupPadding.left, y: s.endPoint.y + groupPadding.top },
            bendPoints: (s.bendPoints || []).map(b => ({ x: b.x + groupPadding.left, y: b.y + groupPadding.top }))
          })),
          labels: (e.labels || []).map(l => l.x !== undefined ? { ...l, x: l.x + groupPadding.left, y: l.y + groupPadding.top } : l)
        }));
        allChildren.push({
          id: `__group_${gIdx}`,
          x: pos.x,
          y: pos.y,
          width: satWidth + groupPadding.left + groupPadding.right,
          height: satHeight + groupPadding.top + groupPadding.bottom,
          children: satRebasedChildren,
          edges: satGroupEdges
        });
      }

      // Build cross-group edges with smart port selection:
      // - Outputs leave from bottom or right side of the source node
      // - Inputs enter from top or left side of the target node
      const crossGroupEdges = [];
      parsed.edges.forEach((e, i) => {
        if (e.sourceIsGroup || e.targetIsGroup) return;
        const sGroup = nodeToGroup.get(e.source);
        const tGroup = nodeToGroup.get(e.target);
        if (sGroup !== undefined && tGroup !== undefined && sGroup !== tGroup) {
          // Find source and target node absolute positions
          let srcPos = null, tgtPos = null;
          allChildren.forEach(gc => {
            (gc.children || []).forEach(c => {
              if (c.id === e.source) srcPos = { x: c.x + gc.x, y: c.y + gc.y, w: c.width, h: c.height };
              if (c.id === e.target) tgtPos = { x: c.x + gc.x, y: c.y + gc.y, w: c.width, h: c.height };
            });
          });
          if (srcPos && tgtPos) {
            const srcCenterX = srcPos.x + srcPos.w / 2;
            const srcCenterY = srcPos.y + srcPos.h / 2;
            const tgtCenterX = tgtPos.x + tgtPos.w / 2;
            const tgtCenterY = tgtPos.y + tgtPos.h / 2;

            const targetIsRight = tgtCenterX > srcCenterX + srcPos.w / 2;
            const targetIsLeft = tgtCenterX < srcCenterX - srcPos.w / 2;

            let startPoint, endPoint, bendPoints;

            // Gap between the last bend and the target top for a clean vertical entry
            const entryGap = 20;

            if (targetIsRight) {
              // Source exits from RIGHT side, target enters from TOP
              startPoint = { x: srcPos.x + srcPos.w, y: srcCenterY };
              endPoint = { x: tgtCenterX, y: tgtPos.y };

              if (startPoint.y <= endPoint.y - entryGap) {
                // Source is above target: go right to tgtCenterX, then straight down
                bendPoints = [
                  { x: tgtCenterX, y: startPoint.y }
                ];
              } else {
                // Source is at same level or below target: go right past target, up, then over and down
                const aboveY = endPoint.y - entryGap;
                const midX = (startPoint.x + tgtCenterX) / 2;
                bendPoints = [
                  { x: midX, y: startPoint.y },
                  { x: midX, y: aboveY },
                  { x: tgtCenterX, y: aboveY }
                ];
              }
            } else if (targetIsLeft) {
              // Source exits from LEFT side, target enters from TOP
              startPoint = { x: srcPos.x, y: srcCenterY };
              endPoint = { x: tgtCenterX, y: tgtPos.y };

              if (startPoint.y <= endPoint.y - entryGap) {
                // Source is above target: go left to tgtCenterX, then straight down
                bendPoints = [
                  { x: tgtCenterX, y: startPoint.y }
                ];
              } else {
                // Source is at same level or below target: go left past target, up, then over and down
                const aboveY = endPoint.y - entryGap;
                const midX = (startPoint.x + tgtCenterX) / 2;
                bendPoints = [
                  { x: midX, y: startPoint.y },
                  { x: midX, y: aboveY },
                  { x: tgtCenterX, y: aboveY }
                ];
              }
            } else {
              // Target is roughly below/above — use bottom/top ports
              startPoint = { x: srcCenterX, y: srcPos.y + srcPos.h };
              endPoint = { x: tgtCenterX, y: tgtPos.y };
              if (Math.abs(srcCenterX - tgtCenterX) > 5) {
                const midY = (startPoint.y + endPoint.y) / 2;
                bendPoints = [
                  { x: startPoint.x, y: midY },
                  { x: endPoint.x, y: midY }
                ];
              } else {
                bendPoints = [];
              }
            }

            // Place label on the first segment of the edge path (between start and first bend)
            let labelX, labelY;
            if (bendPoints.length > 0) {
              labelX = (startPoint.x + bendPoints[0].x) / 2;
              labelY = (startPoint.y + bendPoints[0].y) / 2;
            } else {
              labelX = (startPoint.x + endPoint.x) / 2;
              labelY = (startPoint.y + endPoint.y) / 2;
            }

            const crossEdgeId = `cross_${i}`;
            parsed._edgeMeta.set(crossEdgeId, { connectorType: e.connectorType, color: e.color });
            crossGroupEdges.push({
              id: crossEdgeId,
              sources: [e.source],
              targets: [e.target],
              sections: [{
                startPoint,
                endPoint,
                bendPoints
              }],
              labels: e.label ? [{ ...calculateEdgeLabelDimensions(e.label), x: labelX, y: labelY }] : []
            });
          }
        }
      });

      // Mark flat layout
      parsed._flatLayout = true;

      return {
        id: 'root',
        children: allChildren,
        edges: crossGroupEdges
      };
    }

    // Hierarchical layout: nodes nested inside ELK group containers.
    // Works well when groups don't have re-entrant flows.
    async function layoutHierarchical(parsed, autoNodes, nodeToGroup, groupNameToIdx, elkDirection) {
      const ungrouped = autoNodes.filter(n => !nodeToGroup.has(n.id));
      const elkChildren = ungrouped.map(n => createElkNode(n));

      parsed.groups.forEach((group, idx) => {
        const children = autoNodes.filter(n => nodeToGroup.get(n.id) === idx);
        elkChildren.push({
          id: `__group_${idx}`,
          layoutOptions: { 'elk.padding': '[top=35,left=15,bottom=15,right=15]' },
          children: children.map(n => createElkNode(n)),
          edges: parsed.edges
            .filter(e => nodeToGroup.get(e.source) === idx && nodeToGroup.get(e.target) === idx && !e.sourceIsGroup && !e.targetIsGroup)
            .map((e, i) => {
              const edgeId = `ge_${idx}_${i}`;
              parsed._edgeMeta.set(edgeId, { connectorType: e.connectorType, color: e.color });
              return {
                id: edgeId,
                sources: [e.source],
                targets: [e.target],
                labels: e.label ? [calculateEdgeLabelDimensions(e.label)] : []
              };
            })
        });
      });

      const elkEdges = [];
      parsed.edges.forEach((e, i) => {
        const sGroup = nodeToGroup.get(e.source);
        const tGroup = nodeToGroup.get(e.target);
        if (!e.sourceIsGroup && !e.targetIsGroup && sGroup !== undefined && tGroup !== undefined && sGroup === tGroup) return;

        let sourceId = e.sourceIsGroup ? `__group_${groupNameToIdx.get(e.source)}` : e.source;
        let targetId = e.targetIsGroup ? `__group_${groupNameToIdx.get(e.target)}` : e.target;

        const edgeId = `e_${i}`;
        parsed._edgeMeta.set(edgeId, { connectorType: e.connectorType, color: e.color });
        elkEdges.push({
          id: edgeId,
          sources: [sourceId],
          targets: [targetId],
          labels: e.label ? [calculateEdgeLabelDimensions(e.label)] : []
        });
      });

      const elkGraph = {
        id: 'root',
        layoutOptions: {
          'elk.algorithm': 'layered',
          'elk.direction': elkDirection,
          'elk.spacing.nodeNode': '40',
          'elk.layered.spacing.nodeNodeBetweenLayers': '35',
          'elk.layered.spacing.edgeNodeBetweenLayers': '15',
          'elk.edgeRouting': 'ORTHOGONAL',
          'elk.hierarchyHandling': 'INCLUDE_CHILDREN',
          'elk.layered.layering.strategy': 'NETWORK_SIMPLEX',
          'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
          'elk.edgeLabels.placement': 'CENTER',
          'elk.edgeLabels.inline': 'true',
          'elk.spacing.edgeLabel': '5'
        },
        children: elkChildren,
        edges: elkEdges
      };

      return await elk.layout(elkGraph);
    }

    // Text layout constants
    const TEXT_CONFIG = {
      fontSize: 12,
      minFontSize: 8,
      charWidth: 7,       // Approximate width per character at fontSize 12
      lineHeight: 16,
      padding: 12,
      maxWidth: 200,      // Max width before wrapping
      minWidth: 80
    };

    function wrapText(text, maxWidth) {
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';
      
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = testLine.length * TEXT_CONFIG.charWidth;
        
        if (testWidth > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      
      return lines;
    }

    // Calculate edge label dimensions with wrapping
    function calculateEdgeLabelDimensions(labelText) {
      if (!labelText) return null;

      const maxWidth = 80; // Max width for edge labels (tighter)
      const charWidth = 6; // Character width for font size 10
      const lineHeight = 11; // Tighter line height
      const padding = 1; // Minimal padding

      const lines = wrapText(labelText, maxWidth);
      const width = Math.max(...lines.map(l => l.length * charWidth)) + padding * 2;
      const height = lines.length * lineHeight + padding * 2;

      return { text: labelText, width, height };
    }

    function createElkNode(node) {
      const nodeHasIcon = node.icon && hasIcon(node.icon);
      const iconSpace = nodeHasIcon ? 24 : 0;
      const textMode = node.text || 'wrap'; // wrap, fit, clip
      
      let width, height;
      const label = node.label || node.id;
      
      if (textMode === 'clip' || textMode === 'fit') {
        // Single line, fixed width
        width = Math.min(TEXT_CONFIG.maxWidth, Math.max(TEXT_CONFIG.minWidth, label.length * TEXT_CONFIG.charWidth + TEXT_CONFIG.padding * 2 + iconSpace));
        height = node.shape === 'diamond' ? 60 : 44;
      } else {
        // Wrap mode - calculate wrapped dimensions
        const availableWidth = TEXT_CONFIG.maxWidth - TEXT_CONFIG.padding * 2 - iconSpace;
        const lines = wrapText(label, availableWidth);
        const textWidth = Math.max(...lines.map(l => l.length * TEXT_CONFIG.charWidth));
        
        width = Math.max(TEXT_CONFIG.minWidth, textWidth + TEXT_CONFIG.padding * 2 + iconSpace);
        const textHeight = lines.length * TEXT_CONFIG.lineHeight;
        height = node.shape === 'diamond' 
          ? Math.max(60, textHeight + 30)
          : Math.max(44, textHeight + TEXT_CONFIG.padding * 2);
      }
      
      // Store calculated values for rendering
      node._width = width;
      node._height = height;
      
      return {
        id: node.id,
        width,
        height
      };
    }

    // ============================================
    // Renderer
    // ============================================

    function render(elkResult, parsed) {
      const nodeMap = new Map(parsed.nodes.map(n => [n.id, n]));
      const groupMap = new Map(parsed.groups.map((g, i) => [`__group_${i}`, g]));

      const positioned = [];
      const groupRects = [];

      function process(children, ox = 0, oy = 0) {
        children.forEach(c => {
          const x = (c.x || 0) + ox, y = (c.y || 0) + oy;
          if (c.id.startsWith('__group_')) {
            groupRects.push({ id: c.id, x, y, width: c.width, height: c.height, data: groupMap.get(c.id) });
            if (c.children) process(c.children, x, y);
          } else {
            positioned.push({ id: c.id, x, y, width: c.width, height: c.height });
          }
        });
      }
      process(elkResult.children || []);

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      [...positioned, ...groupRects].forEach(n => {
        minX = Math.min(minX, n.x);
        minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + n.width);
        maxY = Math.max(maxY, n.y + n.height);
      });
      if (!isFinite(minX)) { minX = 0; minY = 0; maxX = 400; maxY = 300; }

      const pad = 50;
      const width = maxX - minX + pad * 2;
      const height = maxY - minY + pad * 2;
      const ox = -minX + pad, oy = -minY + pad;

      const style = getComputedStyle(document.body);
      const nodeFill = style.getPropertyValue('--node-fill').trim();
      const nodeStroke = style.getPropertyValue('--node-stroke').trim();
      const nodeText = style.getPropertyValue('--node-text').trim();
      const edgeStroke = style.getPropertyValue('--edge-stroke').trim();
      const textDim = style.getPropertyValue('--text-dim').trim();
      const groupFill = style.getPropertyValue('--group-fill').trim();
      const groupStroke = style.getPropertyValue('--group-stroke').trim();

      let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}">`;
      svg += `<defs>`;
      svg += `<marker id="arrow" markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto"><polygon points="0 0,6 2,0 4" fill="${edgeStroke}"/></marker>`;
      svg += `<marker id="arrow-rev" markerWidth="6" markerHeight="4" refX="1" refY="2" orient="auto"><polygon points="6 0,0 2,6 4" fill="${edgeStroke}"/></marker>`;
      svg += `</defs>`;

      // Groups
      groupRects.forEach(g => {
        const x = g.x + ox, y = g.y + oy;
        const fill = g.data?.color ? hexToRgba(g.data.color, 0.12) : groupFill;
        const stroke = g.data?.color || groupStroke;
        svg += `<rect x="${x}" y="${y}" width="${g.width}" height="${g.height}" rx="8" fill="${fill}" stroke="${stroke}" stroke-width="1.5" stroke-dasharray="4 2"/>`;
        svg += `<text x="${x + 10}" y="${y + 18}" fill="${g.data?.color || textDim}" font-size="11" font-weight="600" font-family="DM Sans,sans-serif">${esc(g.data?.name || '')}</text>`;
      });

      // Edges
      const posMap = new Map(positioned.map(p => [p.id, { x: p.x + ox, y: p.y + oy, w: p.width, h: p.height }]));

      const dummyEdgeIds = parsed._dummyEdgeIds || new Set();
      const edgeMeta = parsed._edgeMeta || new Map();
      function drawEdges(edges, bx = 0, by = 0) {
        (edges || []).forEach(e => {
          if (dummyEdgeIds.has(e.id)) return; // Skip invisible ordering edges
          const meta = edgeMeta.get(e.id) || {};
          const ct = meta.connectorType || '>';
          const eColor = meta.color || edgeStroke;
          // Determine line style based on connector type
          const isDotted = ct === '--' || ct === '-->';
          const dashAttr = isDotted ? ' stroke-dasharray="6 3"' : '';
          // Determine arrow markers
          let markerStart = '';
          let markerEnd = '';
          if (ct === '>' || ct === '-->') {
            markerEnd = ` marker-end="url(#arrow)"`;
          } else if (ct === '<') {
            markerStart = ` marker-start="url(#arrow-rev)"`;
          } else if (ct === '<>') {
            markerStart = ` marker-start="url(#arrow-rev)"`;
            markerEnd = ` marker-end="url(#arrow)"`;
          }
          // '-' and '--' have no arrows
          if (e.sections) {
            e.sections.forEach(s => {
              let d = `M ${s.startPoint.x + ox + bx} ${s.startPoint.y + oy + by}`;
              (s.bendPoints || []).forEach(b => d += ` L ${b.x + ox + bx} ${b.y + oy + by}`);
              d += ` L ${s.endPoint.x + ox + bx} ${s.endPoint.y + oy + by}`;
              svg += `<path d="${d}" fill="none" stroke="${eColor}" stroke-width="1.5"${dashAttr}${markerStart}${markerEnd}/>`;
            });
            (e.labels || []).forEach(l => {
              if (l.x !== undefined && l.text) {
                let lx = l.x + ox + bx;
                let ly = l.y + oy + by;

                // Snap label to the edge path midpoint for better placement
                if (e.sections && e.sections.length > 0) {
                  const s = e.sections[0];
                  const sp = { x: s.startPoint.x + ox + bx, y: s.startPoint.y + oy + by };
                  const ep = { x: s.endPoint.x + ox + bx, y: s.endPoint.y + oy + by };
                  const bps = (s.bendPoints || []).map(b => ({ x: b.x + ox + bx, y: b.y + oy + by }));
                  // Build full point list
                  const pts = [sp, ...bps, ep];
                  // Find the midpoint along the path
                  let totalLen = 0;
                  for (let pi = 1; pi < pts.length; pi++) {
                    totalLen += Math.hypot(pts[pi].x - pts[pi-1].x, pts[pi].y - pts[pi-1].y);
                  }
                  let halfLen = totalLen / 2;
                  for (let pi = 1; pi < pts.length; pi++) {
                    const segLen = Math.hypot(pts[pi].x - pts[pi-1].x, pts[pi].y - pts[pi-1].y);
                    if (halfLen <= segLen) {
                      const t = segLen > 0 ? halfLen / segLen : 0;
                      lx = pts[pi-1].x + t * (pts[pi].x - pts[pi-1].x);
                      ly = pts[pi-1].y + t * (pts[pi].y - pts[pi-1].y);
                      break;
                    }
                    halfLen -= segLen;
                  }
                }

                // Eraser.io style: simple text on edge, minimal background
                const fontSize = 10;
                const padding = 2;

                // Wrap text if needed
                const maxLabelWidth = 80;
                const lines = wrapText(l.text, maxLabelWidth);
                const lineHeight = 12;

                // Calculate text dimensions for subtle background
                const longestLine = Math.max(...lines.map(line => line.length));
                const textWidth = longestLine * 6;
                const boxWidth = textWidth + padding * 2;
                const boxHeight = lines.length * lineHeight + padding * 2;

                // Very subtle background for readability (semi-transparent)
                const bgColor = nodeFill === '#fff' || nodeFill === '#ffffff' ? 'rgba(255,255,255,0.9)' : 'rgba(30,30,30,0.9)';
                svg += `<rect x="${lx - boxWidth/2}" y="${ly - boxHeight/2}" width="${boxWidth}" height="${boxHeight}" fill="${bgColor}" rx="2" stroke="none"/>`;

                // Draw text centered on edge
                const textStartY = ly - (lines.length - 1) * lineHeight / 2;
                lines.forEach((line, i) => {
                  svg += `<text x="${lx}" y="${textStartY + i * lineHeight}" text-anchor="middle" dominant-baseline="middle" fill="${textDim}" font-size="${fontSize}" font-family="DM Sans,sans-serif">${esc(line)}</text>`;
                });
              }
            });
          }
        });
      }
      drawEdges(elkResult.edges);
      (elkResult.children || []).forEach(c => { if (c.id.startsWith('__group_') && c.edges) drawEdges(c.edges, c.x || 0, c.y || 0); });

      // Nodes
      positioned.forEach(p => {
        const node = nodeMap.get(p.id);
        if (!node) return;
        const x = p.x + ox, y = p.y + oy, w = p.width, h = p.height;
        const fill = node.color || nodeFill;
        const iconPaths = getIconPaths(node.icon);
        const nodeHasIcon = iconPaths !== null;
        const textMode = node.text || 'wrap';
        const label = node.label || node.id;

        // Determine text color based on background for WCAG contrast
        const textColor = node.color ? (isDarkColor(node.color) ? '#ffffff' : '#1a1a1a') : nodeText;

        svg += renderShape(node.shape, x, y, w, h, fill, nodeStroke);

        // Icon (supports multi-path Tabler icons)
        if (nodeHasIcon) {
          svg += `<g transform="translate(${x + 10},${y + h / 2 - 8})"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="${textColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">`;
          iconPaths.forEach(d => { svg += `<path d="${d}"/>`; });
          svg += `</svg></g>`;
        }

        // Text rendering based on mode
        const iconSpace = nodeHasIcon ? 24 : 0;
        const textX = nodeHasIcon ? x + 30 : x + TEXT_CONFIG.padding;
        const availableWidth = w - TEXT_CONFIG.padding * 2 - iconSpace;
        const centerX = nodeHasIcon ? x + 30 + (w - 30) / 2 : x + w / 2;

        if (textMode === 'fit') {
          // Fit mode: shrink font to fit in single line
          const textWidth = label.length * TEXT_CONFIG.charWidth;
          let fontSize = TEXT_CONFIG.fontSize;
          if (textWidth > availableWidth) {
            fontSize = Math.max(TEXT_CONFIG.minFontSize, Math.floor(TEXT_CONFIG.fontSize * availableWidth / textWidth));
          }
          svg += `<text x="${centerX}" y="${y + h / 2 + fontSize / 3}" text-anchor="middle" fill="${textColor}" font-size="${fontSize}" font-family="DM Sans,sans-serif" font-weight="500">${esc(label)}</text>`;
          
        } else if (textMode === 'clip') {
          // Clip mode: truncate with ellipsis, show full text on hover
          const maxChars = Math.floor(availableWidth / TEXT_CONFIG.charWidth);
          const displayText = label.length > maxChars ? label.slice(0, maxChars - 1) + '…' : label;
          const clipId = `clip_${p.id.replace(/[^a-zA-Z0-9]/g, '_')}`;

          svg += `<defs><clipPath id="${clipId}"><rect x="${textX}" y="${y}" width="${availableWidth}" height="${h}"/></clipPath></defs>`;
          svg += `<text x="${centerX}" y="${y + h / 2 + 4}" text-anchor="middle" fill="${textColor}" font-size="12" font-family="DM Sans,sans-serif" font-weight="500" clip-path="url(#${clipId})">`;
          svg += `${esc(displayText)}<title>${esc(label)}</title></text>`;

        } else {
          // Wrap mode (default): wrap text into multiple lines
          const lines = wrapText(label, availableWidth);
          const lineHeight = TEXT_CONFIG.lineHeight;
          const totalTextHeight = lines.length * lineHeight;
          const startY = y + (h - totalTextHeight) / 2 + lineHeight * 0.7;

          lines.forEach((line, i) => {
            svg += `<text x="${centerX}" y="${startY + i * lineHeight}" text-anchor="middle" fill="${textColor}" font-size="12" font-family="DM Sans,sans-serif" font-weight="500">${esc(line)}</text>`;
          });
        }
      });

      svg += '</svg>';
      return { svg, width, height };
    }

    function renderShape(shape, x, y, w, h, fill, stroke) {
      switch (shape) {
        case 'diamond':
          const cx = x + w / 2, cy = y + h / 2;
          return `<polygon points="${cx},${y} ${x + w},${cy} ${cx},${y + h} ${x},${cy}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'stadium': // oval
        case 'ellipse':
          return `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="${h / 2}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'parallelogram':
          const s = 10;
          return `<polygon points="${x + s},${y} ${x + w},${y} ${x + w - s},${y + h} ${x},${y + h}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'cylinder':
          const r = 6;
          return `<path d="M${x} ${y + r} C${x} ${y},${x + w} ${y},${x + w} ${y + r} L${x + w} ${y + h - r} C${x + w} ${y + h},${x} ${y + h},${x} ${y + h - r} Z M${x} ${y + r} C${x} ${y + r * 2},${x + w} ${y + r * 2},${x + w} ${y + r}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'document':
          return `<path d="M${x} ${y} L${x + w} ${y} L${x + w} ${y + h - 8} Q${x + w * 0.75} ${y + h - 4} ${x + w / 2} ${y + h - 8} Q${x + w * 0.25} ${y + h - 12} ${x} ${y + h - 8} Z" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'hexagon':
          const hx = 12;
          return `<polygon points="${x + hx},${y} ${x + w - hx},${y} ${x + w},${y + h/2} ${x + w - hx},${y + h} ${x + hx},${y + h} ${x},${y + h/2}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'trapezoid':
          const tx = 12;
          return `<polygon points="${x + tx},${y} ${x + w - tx},${y} ${x + w},${y + h} ${x},${y + h}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'triangle':
          return `<polygon points="${x + w/2},${y} ${x + w},${y + h} ${x},${y + h}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'star':
          const starPoints = [];
          for (let i = 0; i < 10; i++) {
            const angle = (i * 36 - 90) * Math.PI / 180;
            const radius = i % 2 === 0 ? Math.min(w, h) / 2 : Math.min(w, h) / 4;
            starPoints.push(`${x + w/2 + radius * Math.cos(angle)},${y + h/2 + radius * Math.sin(angle)}`);
          }
          return `<polygon points="${starPoints.join(' ')}" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
        case 'rect':
        default:
          return `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="${fill}" stroke="${stroke}" stroke-width="1.5"/>`;
      }
    }

    function hexToRgba(hex, a) {
      if (!hex.startsWith('#')) return hex;
      const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    function esc(t) {
      return t.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Determine if a color is dark and needs white text
    function isDarkColor(hexColor) {
      if (!hexColor || !hexColor.startsWith('#')) return false;

      // Convert hex to RGB
      const hex = hexColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);

      // WCAG relative luminance (sRGB linearized)
      const srgb = [r, g, b].map(c => {
        c = c / 255;
        return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
      });
      const L = 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];

      // WCAG contrast ratio: white text vs black text
      // L_white = 1.0, L_black = 0.0
      const contrastWithWhite = (1.05) / (L + 0.05);
      const contrastWithBlack = (L + 0.05) / (0.05);

      // Use dark text (#1a1a1a) when black contrast is higher (light bg)
      return contrastWithWhite > contrastWithBlack;
    }

    // ============================================
    // Update Diagram
    // ============================================

    let updateTimer;
    let tablerIconsReady = false;
    async function updateDiagram() {
      const source = editor.value;

      try {
        // Wait for Tabler icons on first render (max 3s, then proceed without)
        if (!tablerIconsReady) {
          await Promise.race([tablerIconsLoading, new Promise(r => setTimeout(r, 3000))]);
          tablerIconsReady = true;
        }

        const parsed = parse(source);
        if (parsed.nodes.length === 0) {
          canvas.innerHTML = '';
          setStatus('Ready', false);
          return;
        }

        const elkResult = await layout(parsed);
        const { svg, width, height } = render(elkResult, parsed);

        canvas.innerHTML = svg;
        canvas.setAttribute('viewBox', `0 0 ${width} ${height}`);

        setStatus(`${parsed.nodes.length} nodes`, false);
      } catch (err) {
        console.error(err);
        setStatus('Error', true);
      }
    }

    function setStatus(text, isError) {
      statusText.textContent = text;
      statusDot.classList.toggle('error', isError);
    }

    function scheduleUpdate() {
      clearTimeout(updateTimer);
      updateTimer = setTimeout(updateDiagram, 150);
    }

    // ============================================
    // Editor Events
    // ============================================

    editor.addEventListener('input', () => {
      if (state.currentFile) {
        const fileData = state.files.get(state.currentFile);
        if (fileData) {
          fileData.modified = fileData.content !== editor.value;
          fileData.content = editor.value; // Update content immediately
          fileData.lastUpdated = Date.now();
          updateSaveStatus();
          saveToLocalStorage(); // Auto-save to localStorage
          scheduleAutoSave(); // Schedule version auto-save
        }
      }
      scheduleUpdate();
    });

    // ============================================
    // Zoom & Pan
    // ============================================

    let isPanning = false, startPan = { x: 0, y: 0 };

    canvasContainer.addEventListener('mousedown', e => {
      if (e.button === 0) {
        isPanning = true;
        startPan = { x: e.clientX - state.pan.x, y: e.clientY - state.pan.y };
      }
    });

    document.addEventListener('mousemove', e => {
      if (isPanning) {
        state.pan.x = e.clientX - startPan.x;
        state.pan.y = e.clientY - startPan.y;
        applyTransform();
      }
    });

    document.addEventListener('mouseup', () => isPanning = false);

    canvasContainer.addEventListener('wheel', e => {
      e.preventDefault();
      state.zoom = Math.max(0.1, Math.min(4, state.zoom * (e.deltaY > 0 ? 0.9 : 1.1)));
      applyTransform();
    });

    function applyTransform() {
      canvas.style.transform = `translate(${state.pan.x}px,${state.pan.y}px) scale(${state.zoom})`;
      canvas.style.transformOrigin = '0 0';
      zoomDisplay.textContent = `${Math.round(state.zoom * 100)}%`;
    }

    document.getElementById('zoomInBtn').addEventListener('click', () => { state.zoom = Math.min(4, state.zoom * 1.2); applyTransform(); });
    document.getElementById('zoomOutBtn').addEventListener('click', () => { state.zoom = Math.max(0.1, state.zoom / 1.2); applyTransform(); });
    document.getElementById('fitBtn').addEventListener('click', () => { state.zoom = 1; state.pan = { x: 0, y: 0 }; applyTransform(); });

    // ============================================
    // Export
    // ============================================

    document.getElementById('exportSvgBtn').addEventListener('click', () => {
      const svgContent = canvas.innerHTML;
      if (!svgContent) return;
      const blob = new Blob([svgContent], { type: 'image/svg+xml' });
      download(blob, (state.currentFile || 'diagram').replace('.flow', '.svg'));
    });

    document.getElementById('exportPngBtn').addEventListener('click', () => {
      const svgContent = canvas.innerHTML;
      if (!svgContent) return;

      // Get viewBox dimensions from the canvas
      const viewBox = canvas.getAttribute('viewBox');
      if (!viewBox) return;
      const [, , width, height] = viewBox.split(' ').map(Number);

      // Create SVG with explicit width and height for proper rendering
      const svgWithDimensions = svgContent.replace(
        /<svg/,
        `<svg width="${width}" height="${height}"`
      );

      const img = new Image();
      img.onload = () => {
        const c = document.createElement('canvas');
        c.width = img.width * 2; c.height = img.height * 2;
        const ctx = c.getContext('2d');
        ctx.scale(2, 2);
        ctx.drawImage(img, 0, 0);
        c.toBlob(blob => download(blob, (state.currentFile || 'diagram').replace('.flow', '.png')), 'image/png');
      };
      img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgWithDimensions)));
    });

    function download(blob, name) {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // ============================================
    // UI Events
    // ============================================

    document.getElementById('openFolderBtn').addEventListener('click', openFolder);
    document.getElementById('openFolderHeaderBtn').addEventListener('click', openFolder);
    document.getElementById('openFolderSidebarBtn').addEventListener('click', openFolder);
    document.getElementById('newFileBtn').addEventListener('click', showNewFileModal);
    document.getElementById('createFirstBtn')?.addEventListener('click', showNewFileModal);
    document.getElementById('refreshBtn').addEventListener('click', refreshFileTree);
    document.getElementById('helpBtn').addEventListener('click', () => document.getElementById('helpModal').classList.add('active'));

    document.getElementById('themeBtn').addEventListener('click', () => {
      state.theme = state.theme === 'dark' ? 'light' : 'dark';
      document.body.setAttribute('data-theme', state.theme);
      // Apply palette for the new theme
      const pc = state.palette[state.theme];
      buildColorPalette(pc.set, pc.shade);
      updatePaletteUI();
      updateGrid();
      updateDiagram();
      if (state.demoMode) saveToLocalStorage();
    });

    // Palette popover toggle
    document.getElementById('paletteBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      const popover = document.getElementById('palettePopover');
      popover.classList.toggle('active');
    });
    // Close popover on outside click
    document.addEventListener('click', (e) => {
      const popover = document.getElementById('palettePopover');
      if (popover.classList.contains('active') && !popover.contains(e.target) && e.target.id !== 'paletteBtn') {
        popover.classList.remove('active');
      }
    });

    // Palette set buttons
    document.getElementById('paletteSetRow').addEventListener('click', (e) => {
      const btn = e.target.closest('[data-set]');
      if (!btn) return;
      const setName = btn.dataset.set;
      state.palette[state.theme].set = setName;
      buildColorPalette(setName, state.palette[state.theme].shade);
      updatePaletteUI();
      updateDiagram();
      if (state.demoMode) saveToLocalStorage();
    });

    // Palette shade buttons
    document.getElementById('paletteShadeRow').addEventListener('click', (e) => {
      const btn = e.target.closest('[data-shade]');
      if (!btn) return;
      const shade = parseInt(btn.dataset.shade);
      state.palette[state.theme].shade = shade;
      buildColorPalette(state.palette[state.theme].set, shade);
      updatePaletteUI();
      updateDiagram();
      if (state.demoMode) saveToLocalStorage();
    });

    function updatePaletteUI() {
      const pc = state.palette[state.theme];
      // Update set pills
      document.querySelectorAll('#paletteSetRow .palette-pill').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.set === pc.set);
      });
      // Update shade pills
      document.querySelectorAll('#paletteShadeRow .palette-pill').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.shade) === pc.shade);
      });
      // Update swatches preview
      const swatches = document.getElementById('paletteSwatches');
      const previewColors = ['red','orange','amber','yellow','lime','green','emerald','teal','cyan','sky','blue','indigo','violet','purple','fuchsia','pink','rose'];
      swatches.innerHTML = previewColors.map(c =>
        `<div class="palette-swatch" style="background:${colorPalette[c] || '#888'}"></div>`
      ).join('');
    }

    // Initialize palette UI
    updatePaletteUI();

    document.getElementById('confirmDeleteBtn').addEventListener('click', async () => {
      const modal = document.getElementById('deleteModal');
      const filename = modal.dataset.filename || state.currentFile;
      modal.classList.remove('active');
      await deleteFile(filename);
    });

    async function deleteFile(filename) {
      if (!filename) return;
      
      if (state.demoMode) {
        state.files.delete(filename);
        // Also delete versions for this file
        delete fileVersions[filename];
        saveVersions();
        
        if (state.currentFile === filename) {
          state.currentFile = null;
          editor.value = '';
          canvas.innerHTML = '';
          document.getElementById('currentFileName').textContent = 'untitled.flow';
        }
        renderDemoFileTree();
        saveToLocalStorage();
        showToast('File deleted');
      } else {
        // Real file system mode
        if (state.directoryHandle) {
          try {
            await state.directoryHandle.removeEntry(filename);
            state.files.delete(filename);
            if (state.currentFile === filename) {
              state.currentFile = null;
              editor.value = '';
              canvas.innerHTML = '';
            }
            await refreshFileTree();
            showToast('File deleted');
          } catch (err) {
            console.error(err);
            showToast('Failed to delete file');
          }
        }
      }
    }

    document.getElementById('confirmNewFileBtn').addEventListener('click', async () => {
      const name = document.getElementById('newFileInput').value.trim();
      if (name) {
        document.getElementById('newFileModal').classList.remove('active');
        await createNewFile(name);
      }
    });

    document.getElementById('newFileInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') document.getElementById('confirmNewFileBtn').click();
    });

    // ============================================
    // Version History UI
    // ============================================

    let compareState = { leftVersion: null, rightVersion: null };

    document.getElementById('versionsBtn').addEventListener('click', () => {
      if (!state.currentFile) {
        showToast('No file selected');
        return;
      }
      showVersionHistory();
    });

    document.getElementById('saveNewVersionBtn').addEventListener('click', () => {
      document.getElementById('versionHistoryModal').classList.remove('active');
      showSaveVersionModal();
    });

    document.getElementById('confirmSaveVersionBtn').addEventListener('click', () => {
      const comment = document.getElementById('versionCommentInput').value.trim();
      if (state.currentFile) {
        const content = editor.value;
        addVersion(state.currentFile, content, comment || 'Manual save');
        lastAutoSaveContent = content;
        showToast('Version saved');
      }
      document.getElementById('saveVersionModal').classList.remove('active');
      document.getElementById('versionCommentInput').value = '';
    });

    document.getElementById('versionCommentInput').addEventListener('keydown', e => {
      if (e.key === 'Enter') document.getElementById('confirmSaveVersionBtn').click();
    });

    document.getElementById('restoreVersionBtn').addEventListener('click', () => {
      if (compareState.leftVersion && state.currentFile) {
        editor.value = compareState.leftVersion.content;
        const fileData = state.files.get(state.currentFile);
        if (fileData) {
          fileData.content = compareState.leftVersion.content;
          fileData.modified = true;
          fileData.lastUpdated = Date.now();
        }
        scheduleUpdate();
        saveToLocalStorage();
        document.getElementById('versionCompareModal').classList.remove('active');
        showToast('Version restored');
      }
    });

    function showSaveVersionModal() {
      document.getElementById('versionCommentInput').value = '';
      document.getElementById('saveVersionModal').classList.add('active');
      setTimeout(() => document.getElementById('versionCommentInput').focus(), 100);
    }

    function showVersionHistory() {
      const versions = getFileVersions(state.currentFile);
      const currentContent = editor.value;
      const versionList = document.getElementById('versionList');
      
      if (versions.length === 0) {
        versionList.innerHTML = `
          <div class="empty-state">
            <p>No saved versions yet</p>
            <p style="font-size: 11px; color: var(--text-muted);">
              Versions are auto-saved every 5 minutes when you make changes.<br>
              Click "Save Current" to save a named version.
            </p>
          </div>
        `;
      } else {
        versionList.innerHTML = versions.map((v, i) => {
          const isCurrent = v.content === currentContent;
          return `
            <div class="version-item ${isCurrent ? 'current' : ''}" data-id="${v.id}">
              <div class="version-header">
                <span class="version-comment">
                  ${escapeHtml(v.comment)}
                  ${isCurrent ? '<span class="version-current-badge">Current</span>' : ''}
                </span>
                <span class="version-time">${formatVersionTime(v.timestamp)}</span>
              </div>
              <div class="version-meta">${formatFullTime(v.timestamp)}</div>
              <div class="version-actions">
                <button class="btn" onclick="previewVersion('${v.id}')">Preview</button>
                <button class="btn" onclick="compareWithCurrent('${v.id}')">Compare</button>
                ${!isCurrent ? `<button class="btn" onclick="restoreVersion('${v.id}')">Restore</button>` : ''}
                ${i > 0 ? `<button class="btn" onclick="compareVersions('${v.id}', '${versions[i-1].id}')">vs Previous</button>` : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      
      document.getElementById('versionHistoryModal').classList.add('active');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function previewVersion(versionId) {
      const versions = getFileVersions(state.currentFile);
      const version = versions.find(v => v.id === versionId);
      if (!version) return;
      
      compareState.leftVersion = version;
      compareState.rightVersion = { content: editor.value, comment: 'Current', timestamp: Date.now() };
      
      document.getElementById('compareLeftLabel').textContent = version.comment + ' (' + formatVersionTime(version.timestamp) + ')';
      document.getElementById('compareRightLabel').textContent = 'Current';
      
      document.getElementById('compareLeft').textContent = version.content;
      document.getElementById('compareRight').textContent = editor.value;
      
      document.getElementById('restoreVersionBtn').style.display = 'inline-block';
      document.getElementById('versionHistoryModal').classList.remove('active');
      document.getElementById('versionCompareModal').classList.add('active');
    }

    function compareWithCurrent(versionId) {
      previewVersion(versionId);
    }

    function compareVersions(leftId, rightId) {
      const versions = getFileVersions(state.currentFile);
      const leftVersion = versions.find(v => v.id === leftId);
      const rightVersion = versions.find(v => v.id === rightId);
      if (!leftVersion || !rightVersion) return;
      
      compareState.leftVersion = leftVersion;
      compareState.rightVersion = rightVersion;
      
      document.getElementById('compareLeftLabel').textContent = leftVersion.comment + ' (' + formatVersionTime(leftVersion.timestamp) + ')';
      document.getElementById('compareRightLabel').textContent = rightVersion.comment + ' (' + formatVersionTime(rightVersion.timestamp) + ')';
      
      // Simple diff highlighting
      document.getElementById('compareLeft').innerHTML = highlightDiff(leftVersion.content, rightVersion.content, 'left');
      document.getElementById('compareRight').innerHTML = highlightDiff(rightVersion.content, leftVersion.content, 'right');
      
      document.getElementById('restoreVersionBtn').style.display = 'inline-block';
      document.getElementById('versionHistoryModal').classList.remove('active');
      document.getElementById('versionCompareModal').classList.add('active');
    }

    function restoreVersion(versionId) {
      const versions = getFileVersions(state.currentFile);
      const version = versions.find(v => v.id === versionId);
      if (!version) return;
      
      editor.value = version.content;
      const fileData = state.files.get(state.currentFile);
      if (fileData) {
        fileData.content = version.content;
        fileData.modified = true;
        fileData.lastUpdated = Date.now();
      }
      scheduleUpdate();
      saveToLocalStorage();
      document.getElementById('versionHistoryModal').classList.remove('active');
      showToast('Version restored');
    }

    function highlightDiff(text1, text2, side) {
      const lines1 = text1.split('\n');
      const lines2 = text2.split('\n');
      const result = [];
      
      const set2 = new Set(lines2);
      
      for (const line of lines1) {
        const escaped = escapeHtml(line);
        if (!set2.has(line) && line.trim()) {
          result.push(`<span class="diff-line ${side === 'left' ? 'diff-remove' : 'diff-add'}">${escaped || ' '}</span>`);
        } else {
          result.push(escaped || ' ');
        }
      }
      
      return result.join('\n');
    }

    // Close modals on overlay click
    document.querySelectorAll('.modal-overlay').forEach(m => {
      m.addEventListener('click', e => { if (e.target === m) m.classList.remove('active'); });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', e => {
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault();
        // Ctrl+S now prompts for version comment
        if (state.currentFile) {
          showSaveVersionModal();
        }
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
        e.preventDefault();
        showNewFileModal();
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'o') {
        e.preventDefault();
        openFolder();
      }
    });

    // ============================================
    // Grid & Utils
    // ============================================

    function updateGrid() {
      const grid = document.getElementById('gridPattern');
      const color = getComputedStyle(document.body).getPropertyValue('--border').trim();
      grid.innerHTML = `<defs><pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="0.5" fill="${color}"/></pattern></defs><rect width="100%" height="100%" fill="url(#grid)"/>`;
    }

    function showToast(msg) {
      const container = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = msg;
      container.appendChild(toast);
      setTimeout(() => toast.remove(), 2500);
    }

    // ============================================
    // Sample Project Data
    // ============================================

    const sampleFiles = {
      'welcome.flow': `// Welcome to FlowScript!
// Eraser.io compatible syntax

Start [shape: oval, icon: globe]
Read Guide [icon: code]
Try Examples [icon: check]
Create Own [shape: oval, color: green, icon: user]

Start > Read Guide
Read Guide > Try Examples
Try Examples > Create Own

// Syntax:
// [shape: oval/diamond/cylinder/parallelogram]
// [color: red/green/blue/yellow/purple/orange]
// [icon: globe/user/check/code/database/server]
// [text: wrap/fit/clip]`,

      'login-flow.flow': `// User Login Flow

Start [shape: oval, icon: globe]
Login Page [shape: parallelogram, icon: user]
Enter Credentials
Validate [shape: diamond]
Invalid [color: red, icon: x]
Check 2FA [shape: diamond]
Enter Code [shape: parallelogram]
Verify Code [shape: diamond]
Success [shape: oval, color: green, icon: check]

Start > Login Page
Login Page > Enter Credentials
Enter Credentials > Validate

Validate > Invalid: no
Validate > Check 2FA: yes
Invalid > Login Page

Check 2FA > Enter Code: enabled
Check 2FA > Success: disabled
Enter Code > Verify Code

Verify Code > Invalid: no
Verify Code > Success: yes`,

      'api-architecture.flow': `// API Architecture

Frontend [color: purple] {
  React App [icon: code]
  Redux Store [icon: cache]
}

Backend [color: blue] {
  API Gateway [icon: api]
  Auth Service [icon: lock]
  User Service [icon: user]
  Database [shape: cylinder, icon: database]
}

Cloud [color: orange] {
  Lambda [icon: server]
  S3 Storage [icon: database]
  CDN [icon: globe]
}

Frontend > Backend: REST API
Backend > Cloud: async jobs
Cloud > Frontend: static assets`,

      'showcase.flow': `// FlowScript Showcase (Top-Down)
// Every shape, text mode, connection type, colors, icons & groups

// === SHAPES ===
Shapes [color: blue] {
  Rectangle
  Oval [shape: oval]
  Diamond [shape: diamond]
  Cylinder [shape: cylinder]
  Parallelogram [shape: parallelogram]
  Hexagon [shape: hexagon]
  Trapezoid [shape: trapezoid]
  Triangle [shape: triangle]
  Document [shape: document]
  Ellipse [shape: ellipse]
  Star [shape: star]
}

// === COLORS ===
Colors [color: gray] {
  Red [color: red]
  Green [color: green]
  Blue [color: blue]
  Yellow [color: yellow]
  Purple [color: purple]
  Orange [color: orange]
  Pink [color: pink]
  Cyan [color: cyan]
  Teal [color: teal]
  Amber [color: amber]
}

// === ICONS (from 5000+ Tabler Icons) ===
Icons [color: purple] {
  Rocket [icon: rocket, color: red]
  User [icon: user, color: blue]
  Database [icon: database, color: green]
  Shield [icon: shield-check, color: yellow]
  CPU [icon: cpu, color: orange]
}

// === TEXT MODES ===
Text Modes [color: teal] {
  Wrap mode is the default [label: Wrap mode is the default text mode]
  Fit [text: fit, label: This is fit mode shrinking to one line]
  Clip [text: clip, label: This is clip mode truncating long text with ellipsis]
}

// === CONNECTIONS ===
Connections [color: orange] {
  Arrow Start [shape: oval, color: green]
  Arrow End [shape: oval]
  Line Start [shape: oval, color: green]
  Line End [shape: oval]
  Dotted Start [shape: oval, color: green]
  Dotted End [shape: oval]
  DotArrow Start [shape: oval, color: green]
  DotArrow End [shape: oval]
  Bidi Left [shape: oval, color: green]
  Bidi Right [shape: oval]
  Reverse End [shape: oval, color: green]
  Reverse Start [shape: oval]
  Chain A [shape: oval, color: green]
  Chain B [shape: oval]
  Chain C [shape: oval]
  Branch Root [shape: oval, color: green]
  Branch X [shape: oval]
  Branch Y [shape: oval]
  Branch Z [shape: oval]
}

// Arrow: A > B
Arrow Start > Arrow End : arrow
// Line: A - B
Line Start - Line End : line
// Dotted: A -- B
Dotted Start -- Dotted End : dotted
// Dotted arrow: A --> B
DotArrow Start --> DotArrow End : dotted arrow
// Bidirectional: A <> B
Bidi Left <> Bidi Right : bidirectional
// Reverse: A < B
Reverse Start < Reverse End : reverse
// Chain: A > B > C
Chain A > Chain B > Chain C : chain
// Branch: A > B, C, D
Branch Root > Branch X, Branch Y, Branch Z

// Shape chain
Rectangle > Oval
Oval > Diamond : labeled
Diamond > Cylinder > Parallelogram > Hexagon
Hexagon > Trapezoid > Triangle > Document
Document > Ellipse > Star

// Color connections
Red - Green
Blue -- Yellow
Purple --> Orange
Pink <> Cyan
Amber < Teal

// Group connections: using different types
Shapes > Colors : solid arrow
Colors -- Icons : dotted line
Icons --> Text Modes : dotted arrow
Text Modes <> Connections : bidirectional`,

      'showcase-right.flow': `// FlowScript Showcase (Left-to-Right)
// Same showcase in right direction
direction right

// === SHAPES ===
Shapes [color: blue] {
  Rectangle
  Oval [shape: oval]
  Diamond [shape: diamond]
  Cylinder [shape: cylinder]
  Parallelogram [shape: parallelogram]
  Hexagon [shape: hexagon]
  Trapezoid [shape: trapezoid]
  Triangle [shape: triangle]
  Document [shape: document]
  Ellipse [shape: ellipse]
  Star [shape: star]
}

// === COLORS ===
Colors [color: gray] {
  Red [color: red]
  Green [color: green]
  Blue [color: blue]
  Yellow [color: yellow]
  Purple [color: purple]
  Orange [color: orange]
  Pink [color: pink]
  Cyan [color: cyan]
  Teal [color: teal]
  Amber [color: amber]
}

// === ICONS (from 5000+ Tabler Icons) ===
Icons [color: purple] {
  Rocket [icon: rocket, color: red]
  User [icon: user, color: blue]
  Database [icon: database, color: green]
  Shield [icon: shield-check, color: yellow]
  CPU [icon: cpu, color: orange]
}

// === TEXT MODES ===
Text Modes [color: teal] {
  Wrap mode is the default [label: Wrap mode is the default text mode]
  Fit [text: fit, label: This is fit mode shrinking to one line]
  Clip [text: clip, label: This is clip mode truncating long text with ellipsis]
}

// === CONNECTIONS ===
Connections [color: orange] {
  Arrow Start [shape: oval, color: green]
  Arrow End [shape: oval]
  Line Start [shape: oval, color: green]
  Line End [shape: oval]
  Dotted Start [shape: oval, color: green]
  Dotted End [shape: oval]
  DotArrow Start [shape: oval, color: green]
  DotArrow End [shape: oval]
  Bidi Left [shape: oval, color: green]
  Bidi Right [shape: oval]
  Reverse End [shape: oval, color: green]
  Reverse Start [shape: oval]
  Chain A [shape: oval, color: green]
  Chain B [shape: oval]
  Chain C [shape: oval]
  Branch Root [shape: oval, color: green]
  Branch X [shape: oval]
  Branch Y [shape: oval]
  Branch Z [shape: oval]
}

// Arrow: A > B
Arrow Start > Arrow End : arrow
// Line: A - B
Line Start - Line End : line
// Dotted: A -- B
Dotted Start -- Dotted End : dotted
// Dotted arrow: A --> B
DotArrow Start --> DotArrow End : dotted arrow
// Bidirectional: A <> B
Bidi Left <> Bidi Right : bidirectional
// Reverse: A < B
Reverse Start < Reverse End : reverse
// Chain: A > B > C
Chain A > Chain B > Chain C : chain
// Branch: A > B, C, D
Branch Root > Branch X, Branch Y, Branch Z

// Shape chain
Rectangle > Oval
Oval > Diamond : labeled
Diamond > Cylinder > Parallelogram > Hexagon
Hexagon > Trapezoid > Triangle > Document
Document > Ellipse > Star

// Color connections
Red - Green
Blue -- Yellow
Purple --> Orange
Pink <> Cyan
Amber < Teal

// Group connections: using different types
Shapes > Colors : solid arrow
Colors -- Icons : dotted line
Icons --> Text Modes : dotted arrow
Text Modes <> Connections : bidirectional`,

      'order-process.flow': `// E-Commerce Order Process

Start [shape: oval, icon: globe]
Receive Order [shape: parallelogram, icon: mail]
Check Inventory [shape: diamond]
Out of Stock [color: yellow, icon: alert]
Notify Customer [icon: mail]
Process Payment [shape: diamond]
Payment Failed [color: red, icon: x]
Retry Payment [shape: diamond]
Cancel Order [color: red, icon: x]
Prepare Shipment [icon: server]
Ship Order [icon: globe]
Complete [shape: oval, color: green, icon: check]

Start > Receive Order
Receive Order > Check Inventory

Check Inventory > Out of Stock: no
Check Inventory > Process Payment: yes
Out of Stock > Notify Customer
Notify Customer > Cancel Order

Process Payment > Payment Failed: failed
Process Payment > Prepare Shipment: success
Payment Failed > Retry Payment

Retry Payment > Process Payment: yes
Retry Payment > Cancel Order: no

Prepare Shipment > Ship Order
Ship Order > Complete`
    };

    // ============================================
    // Demo Mode (In-Memory)
    // ============================================

    function loadSampleProject() {
      // Set up in-memory demo mode
      state.directoryHandle = null;
      state.demoMode = true;
      
      // Try to load from localStorage first
      const saved = loadFromLocalStorage();
      
      if (saved) {
        // Restore saved state
        Object.entries(saved.files).forEach(([name, fileData]) => {
          state.files.set(name, {
            handle: null,
            content: fileData.content,
            modified: false,
            lastUpdated: fileData.lastUpdated
          });
        });

        // Merge in any new sample files that didn't exist in the saved state
        const now = Date.now();
        Object.entries(sampleFiles).forEach(([name, content]) => {
          if (!state.files.has(name)) {
            state.files.set(name, { handle: null, content, modified: false, lastUpdated: now });
          }
        });

        if (saved.sortBy) state.sortBy = saved.sortBy;
        if (saved.theme) {
          state.theme = saved.theme;
          document.body.setAttribute('data-theme', state.theme);
        }
        if (saved.palette) {
          state.palette = saved.palette;
        }
        // Apply the palette for the current theme
        const pc = state.palette[state.theme];
        buildColorPalette(pc.set, pc.shade);
        updatePaletteUI();

        // Update UI
        document.getElementById('projectLabel').innerHTML = '<strong>Local Project</strong> <span style="color: var(--text-muted); font-size: 11px;">(browser)</span>';
        
        // Show project UI
        document.getElementById('noProjectState').style.display = 'none';
        document.getElementById('sidebar').style.display = 'flex';
        document.getElementById('sidebarResize').style.display = 'block';
        document.getElementById('editorPanel').style.display = 'flex';
        document.getElementById('editorResize').style.display = 'block';
        document.getElementById('canvasPanel').style.display = 'block';

        renderDemoFileTree();
        
        // Restore current file or open first
        const fileToOpen = saved.currentFile && state.files.has(saved.currentFile) 
          ? saved.currentFile 
          : getSortedFiles()[0];
        if (fileToOpen) openDemoFile(fileToOpen);
        
        updateGrid();
        setupSortListeners();
        updateSortButtonState();
        return;
      }
      
      // No saved data - load sample files with different timestamps
      const now = Date.now();
      const fileList = Object.entries(sampleFiles);
      fileList.forEach(([name, content], idx) => {
        state.files.set(name, { 
          handle: null, 
          content, 
          modified: false,
          lastUpdated: now - (idx * 3600000)
        });
      });

      // Update UI
      document.getElementById('projectLabel').innerHTML = '<strong>Sample Project</strong> <span style="color: var(--text-muted); font-size: 11px;">(demo)</span>';
      
      // Show project UI
      document.getElementById('noProjectState').style.display = 'none';
      document.getElementById('sidebar').style.display = 'flex';
      document.getElementById('sidebarResize').style.display = 'block';
      document.getElementById('editorPanel').style.display = 'flex';
      document.getElementById('editorResize').style.display = 'block';
      document.getElementById('canvasPanel').style.display = 'block';

      renderDemoFileTree();
      openDemoFile('welcome.flow');
      updateGrid();
      setupSortListeners();
      
      // Save initial state
      saveToLocalStorage();
    }
    
    function updateSortButtonState() {
      const sortNameBtn = document.getElementById('sortNameBtn');
      const sortRecentBtn = document.getElementById('sortRecentBtn');
      if (state.sortBy === 'recent') {
        sortRecentBtn.classList.add('active');
        sortNameBtn.classList.remove('active');
      } else {
        sortNameBtn.classList.add('active');
        sortRecentBtn.classList.remove('active');
      }
    }

    function getSortedFiles() {
      const files = Array.from(state.files.entries());
      
      if (state.sortBy === 'recent') {
        // Sort by lastUpdated descending (most recent first)
        files.sort((a, b) => (b[1].lastUpdated || 0) - (a[1].lastUpdated || 0));
      } else {
        // Sort by name ascending
        files.sort((a, b) => a[0].localeCompare(b[0]));
      }
      
      return files.map(([name]) => name);
    }

    function renderDemoFileTree() {
      const files = getSortedFiles();
      
      if (files.length === 0) {
        fileTree.innerHTML = `
          <div class="empty-state">
            <p>No .flow files yet</p>
            <button class="btn" onclick="showNewFileModal()">Create first file</button>
          </div>
        `;
        return;
      }
      
      fileTree.innerHTML = files.map(name => {
        const fileData = state.files.get(name);
        const timeAgo = fileData?.lastUpdated ? getTimeAgo(fileData.lastUpdated) : '';
        return `
        <div class="file-item ${state.currentFile === name ? 'active' : ''} ${fileData?.modified ? 'modified' : ''}" data-file="${name}">
          <svg class="file-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z"/>
            <path d="M14 2v6h6"/>
          </svg>
          <span class="file-name">${name}</span>
          ${state.sortBy === 'recent' && timeAgo && !fileData?.modified ? `<span class="file-time">${timeAgo}</span>` : ''}
          <button class="file-delete-btn" data-delete="${name}" title="Delete file">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polyline points="3,6 5,6 21,6"/>
              <path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
            </svg>
          </button>
        </div>
      `}).join('');

      fileTree.querySelectorAll('.file-item').forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't open file if clicking delete button
          if (e.target.closest('.file-delete-btn')) return;
          openDemoFile(item.dataset.file);
        });
      });

      fileTree.querySelectorAll('.file-delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const filename = btn.dataset.delete;
          showDeleteConfirmation(filename);
        });
      });
    }

    function showDeleteConfirmation(filename) {
      document.getElementById('deleteFileName').textContent = filename;
      document.getElementById('deleteModal').dataset.filename = filename;
      document.getElementById('deleteModal').classList.add('active');
    }

    function getTimeAgo(timestamp) {
      const seconds = Math.floor((Date.now() - timestamp) / 1000);
      if (seconds < 60) return 'now';
      const minutes = Math.floor(seconds / 60);
      if (minutes < 60) return `${minutes}m`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours}h`;
      const days = Math.floor(hours / 24);
      return `${days}d`;
    }

    function setupSortListeners() {
      const sortNameBtn = document.getElementById('sortNameBtn');
      const sortRecentBtn = document.getElementById('sortRecentBtn');
      
      sortNameBtn.addEventListener('click', () => {
        state.sortBy = 'name';
        sortNameBtn.classList.add('active');
        sortRecentBtn.classList.remove('active');
        if (state.demoMode) {
          renderDemoFileTree();
          saveToLocalStorage();
        } else {
          refreshFileTree();
        }
      });
      
      sortRecentBtn.addEventListener('click', () => {
        state.sortBy = 'recent';
        sortRecentBtn.classList.add('active');
        sortNameBtn.classList.remove('active');
        if (state.demoMode) {
          renderDemoFileTree();
          saveToLocalStorage();
        } else {
          refreshFileTree();
        }
      });
    }

    function openDemoFile(filename) {
      const fileData = state.files.get(filename);
      if (!fileData) return;

      state.currentFile = filename;
      editor.value = fileData.content;
      document.getElementById('currentFileName').textContent = filename;

      renderDemoFileTree();
      updateDiagram();
      updateSaveStatus();
      saveToLocalStorage();
    }

    // Override save for demo mode
    const originalSaveCurrentFile = saveCurrentFile;
    saveCurrentFile = async function() {
      if (state.demoMode) {
        // In demo mode, save to memory and localStorage
        const fileData = state.files.get(state.currentFile);
        if (fileData) {
          fileData.content = editor.value;
          fileData.modified = false;
          fileData.lastUpdated = Date.now();
          updateSaveStatus();
          renderDemoFileTree();
          saveToLocalStorage();
          showToast('Saved');
        }
        return;
      }
      return originalSaveCurrentFile();
    };

    // Override create new file for demo mode
    const originalCreateNewFile = createNewFile;
    createNewFile = async function(filename) {
      if (state.demoMode) {
        if (!filename.endsWith('.flow')) filename += '.flow';
        if (state.files.has(filename)) {
          showToast('File already exists');
          return;
        }
        
        const content = `// ${filename.replace('.flow', '')}

Start [shape: oval]
Process
End [shape: oval]

Start > Process
Process > End`;

        state.files.set(filename, { handle: null, content, modified: false, lastUpdated: Date.now() });
        renderDemoFileTree();
        openDemoFile(filename);
        saveToLocalStorage();
        showToast('File created');
        return;
      }
      return originalCreateNewFile(filename);
    };

    // Override delete for demo mode
    const originalDeleteCurrentFile = deleteCurrentFile;
    deleteCurrentFile = async function() {
      if (state.demoMode) {
        state.files.delete(state.currentFile);
        state.currentFile = null;
        editor.value = '';
        canvas.innerHTML = '';
        renderDemoFileTree();
        
        // Open first remaining file
        const firstFile = getSortedFiles()[0];
        if (firstFile) openDemoFile(firstFile);
        
        saveToLocalStorage();
        showToast('File deleted');
        return;
      }
      return originalDeleteCurrentFile();
    };

    // Override refresh for demo mode
    const originalRefreshFileTree = refreshFileTree;
    refreshFileTree = async function() {
      if (state.demoMode) {
        renderDemoFileTree();
        return;
      }
      return originalRefreshFileTree();
    };

    // Update save status for demo mode
    const originalUpdateSaveStatus = updateSaveStatus;
    updateSaveStatus = function() {
      const fileData = state.currentFile ? state.files.get(state.currentFile) : null;
      
      if (fileData?.modified) {
        saveStatus.textContent = state.demoMode ? 'Modified (demo)' : 'Modified';
        statusDot.classList.add('modified');
        statusDot.classList.remove('error');
      } else {
        saveStatus.textContent = 'Saved';
        statusDot.classList.remove('modified', 'error');
      }
    };

    // Track modifications in demo mode
    editor.addEventListener('input', () => {
      if (state.currentFile) {
        const fileData = state.files.get(state.currentFile);
        if (fileData) {
          fileData.modified = fileData.content !== editor.value;
          if (state.demoMode) renderDemoFileTree();
          updateSaveStatus();
        }
      }
      scheduleUpdate();
    });

    // ============================================
    // Init
    // ============================================

    if (!hasFileSystemAccess) {
      document.querySelector('.no-project p').textContent = 'Your browser does not support the File System Access API. Please use Chrome, Edge, or another Chromium-based browser for full functionality. Loading demo mode...';
    }

    // Load versions from localStorage
    loadVersions();

    // Always start with sample project
    loadSampleProject();
  </script>
</body>
</html>
